!function($) {
    "use strict";
    $.jqplot.CanvasGridRenderer = function() {
        this.shadowRenderer = new $.jqplot.ShadowRenderer();
    }, $.jqplot.CanvasGridRenderer.prototype.init = function(options) {
        this._ctx = null, $.extend(!0, this, options);
        var sopts = {
            lineJoin: "miter",
            lineCap: "round",
            fill: !1,
            isarc: !1,
            angle: this.shadowAngle,
            offset: this.shadowOffset,
            alpha: this.shadowAlpha,
            depth: this.shadowDepth,
            lineWidth: this.shadowWidth,
            closePath: !1,
            strokeStyle: this.shadowColor
        };
        this.renderer.shadowRenderer.init(sopts);
    }, $.jqplot.CanvasGridRenderer.prototype.createElement = function(plot) {
        var elem, w, h;
        return this._elem && ($.jqplot.use_excanvas && window.G_vmlCanvasManager.uninitElement && (elem = this._elem.get(0), 
        window.G_vmlCanvasManager.uninitElement(elem), elem = null), this._elem.emptyForce(), 
        this._elem = null), elem = plot.canvasManager.getCanvas(), w = this._plotDimensions.width, 
        h = this._plotDimensions.height, elem.width = w, elem.height = h, this._elem = $(elem).addClass("jqplot-grid-canvas").css({
            position: "absolute",
            left: 0,
            top: 0
        }), elem = plot.canvasManager.initCanvas(elem), this._top = this._offsets.top, this._bottom = h - this._offsets.bottom, 
        this._left = this._offsets.left, this._right = w - this._offsets.right, this._width = this._right - this._left, 
        this._height = this._bottom - this._top, elem = null, this._elem;
    }, $.jqplot.CanvasGridRenderer.prototype.draw = function() {
        var ctx, axes, ax, i, name, axis, ticks, numticks, drawLine, points;
        for (this._ctx = this._elem.get(0).getContext("2d"), ctx = this._ctx, axes = this._axes, 
        ctx.save(), ctx.clearRect(0, 0, this._plotDimensions.width, this._plotDimensions.height), 
        ctx.fillStyle = this.backgroundColor || this.background, ctx.fillRect(this._left, this._top, this._width, this._height), 
        ctx.save(), ctx.lineJoin = "miter", ctx.lineCap = "butt", ctx.lineWidth = this.gridLineWidth, 
        ctx.strokeStyle = this.gridLineColor, ax = [ "xaxis", "yaxis", "x2axis", "y2axis" ], 
        drawLine = function(bx, by, ex, ey, opts) {
            ctx.save(), opts = opts || {}, (null === opts.lineWidth || 0 !== opts.lineWidth) && ($.extend(!0, ctx, opts), 
            ctx.beginPath(), ctx.moveTo(bx, by), ctx.lineTo(ex, ey), ctx.stroke(), ctx.restore());
        }, this.renderXaxis = function(t, pos, axis) {
            var s, m, e, b;
            if (t.showGridline && this.drawGridlines && (!t.isMinorTick && axis.drawMajorGridlines || t.isMinorTick && axis.drawMinorGridlines) && drawLine(pos, this._top, pos, this._bottom), 
            t.showMark && t.mark && (!t.isMinorTick && axis.drawMajorTickMarks || t.isMinorTick && axis.drawMinorTickMarks)) {
                switch (s = t.markSize, m = t.mark, pos = Math.round(axis.u2p(t.value)) + .5, m) {
                  case "outside":
                    b = this._bottom, e = this._bottom + s;
                    break;

                  case "inside":
                    b = this._bottom - s, e = this._bottom;
                    break;

                  case "cross":
                    b = this._bottom - s, e = this._bottom + s;
                    break;

                  default:
                    b = this._bottom, e = this._bottom + s;
                }
                this.shadow && this.renderer.shadowRenderer.draw(ctx, [ [ pos, b ], [ pos, e ] ], {
                    lineCap: "butt",
                    lineWidth: this.gridLineWidth,
                    offset: .75 * this.gridLineWidth,
                    depth: 2,
                    fill: !1,
                    closePath: !1
                }), drawLine(pos, b, pos, e);
            }
        }, this.renderYaxis = function(t, pos, axis) {
            var s, m, e, b;
            if (t.showGridline && this.drawGridlines && (!t.isMinorTick && axis.drawMajorGridlines || t.isMinorTick && axis.drawMinorGridlines) && drawLine(this._right, pos, this._left, pos), 
            t.showMark && t.mark && (!t.isMinorTick && axis.drawMajorTickMarks || t.isMinorTick && axis.drawMinorTickMarks)) {
                switch (s = t.markSize, m = t.mark, pos = Math.round(axis.u2p(t.value)) + .5, m) {
                  case "outside":
                    b = this._left - s, e = this._left;
                    break;

                  case "inside":
                    b = this._left, e = this._left + s;
                    break;

                  case "cross":
                    b = this._left - s, e = this._left + s;
                    break;

                  default:
                    b = this._left - s, e = this._left;
                }
                this.shadow && this.renderer.shadowRenderer.draw(ctx, [ [ b, pos ], [ e, pos ] ], {
                    lineCap: "butt",
                    lineWidth: 1.5 * this.gridLineWidth,
                    offset: .75 * this.gridLineWidth,
                    fill: !1,
                    closePath: !1
                }), drawLine(b, pos, e, pos, {
                    strokeStyle: axis.borderColor
                });
            }
        }, this.renderX2axis = function(t, pos, axis) {
            var s, m, b, e;
            if (t.showGridline && this.drawGridlines && (!t.isMinorTick && axis.drawMajorGridlines || t.isMinorTick && axis.drawMinorGridlines) && drawLine(pos, this._bottom, pos, this._top), 
            t.showMark && t.mark && (!t.isMinorTick && axis.drawMajorTickMarks || t.isMinorTick && axis.drawMinorTickMarks)) {
                switch (s = t.markSize, m = t.mark, pos = Math.round(axis.u2p(t.value)) + .5, m) {
                  case "outside":
                    b = this._top - s, e = this._top;
                    break;

                  case "inside":
                    b = this._top, e = this._top + s;
                    break;

                  case "cross":
                    b = this._top - s, e = this._top + s;
                    break;

                  default:
                    b = this._top - s, e = this._top;
                }
                this.shadow && this.renderer.shadowRenderer.draw(ctx, [ [ pos, b ], [ pos, e ] ], {
                    lineCap: "butt",
                    lineWidth: this.gridLineWidth,
                    offset: .75 * this.gridLineWidth,
                    depth: 2,
                    fill: !1,
                    closePath: !1
                }), drawLine(pos, b, pos, e);
            }
        }, this.renderY2axis = function(t, pos, axis) {
            var s, m, b, e;
            if (t.showGridline && this.drawGridlines && (!t.isMinorTick && axis.drawMajorGridlines || t.isMinorTick && axis.drawMinorGridlines) && drawLine(this._left, pos, this._right, pos), 
            t.showMark && t.mark && (!t.isMinorTick && axis.drawMajorTickMarks || t.isMinorTick && axis.drawMinorTickMarks)) {
                switch (s = t.markSize, m = t.mark, pos = Math.round(axis.u2p(t.value)) + .5, m) {
                  case "outside":
                    b = this._right, e = this._right + s;
                    break;

                  case "inside":
                    b = this._right - s, e = this._right;
                    break;

                  case "cross":
                    b = this._right - s, e = this._right + s;
                    break;

                  default:
                    b = this._right, e = this._right + s;
                }
                this.shadow && this.renderer.shadowRenderer.draw(ctx, [ [ b, pos ], [ e, pos ] ], {
                    lineCap: "butt",
                    lineWidth: 1.5 * this.gridLineWidth,
                    offset: .75 * this.gridLineWidth,
                    fill: !1,
                    closePath: !1
                }), drawLine(b, pos, e, pos, {
                    strokeStyle: axis.borderColor
                });
            }
        }, this.drawXaxices = function(name, axis, ticks, numticks) {
            var j, t, pos, bopts = {};
            if (!axis.show) return axis = null, ticks = null, this;
            if (axis.drawBaseline) switch (null !== axis.baselineWidth && (bopts.lineWidth = axis.baselineWidth), 
            null !== axis.baselineColor && (bopts.strokeStyle = axis.baselineColor), name) {
              case "xaxis":
                drawLine(this._left, this._bottom, this._right, this._bottom, bopts);
                break;

              case "yaxis":
                drawLine(this._left, this._bottom, this._left, this._top, bopts);
                break;

              case "x2axis":
                drawLine(this._left, this._bottom, this._right, this._bottom, bopts);
                break;

              case "y2axis":
                drawLine(this._right, this._bottom, this._right, this._top, bopts);
            }
            for (j = numticks; j > 0; j--) if (t = ticks[j - 1], t.show) switch (pos = Math.round(axis.u2p(t.value)) + .5, 
            name) {
              case "xaxis":
                this.renderXaxis(t, pos, axis);
                break;

              case "yaxis":
                this.renderYaxis(t, pos, axis);
                break;

              case "x2axis":
                this.renderX2axis(t, pos, axis);
                break;

              case "y2axis":
                this.renderY2axis(t, pos, axis);
            }
            return t = null, axis = null, ticks = null, this;
        }, this.drawYaxices = function(axis, ticks) {
            var tn, t0, left, points, t, j, pos, s, m, b, e;
            if (!axis.show) return axis = null, void (ticks = null);
            for (tn = ticks[axis.numberTicks - 1], t0 = ticks[0], left = axis.getLeft(), points = [ [ left, tn.getTop() + tn.getHeight() / 2 ], [ left, t0.getTop() + t0.getHeight() / 2 + 1 ] ], 
            this.shadow && this.renderer.shadowRenderer.draw(ctx, points, {
                lineCap: "butt",
                fill: !1,
                closePath: !1
            }), drawLine(points[0][0], points[0][1], points[1][0], points[1][1], {
                lineCap: "butt",
                strokeStyle: axis.borderColor,
                lineWidth: axis.borderWidth
            }), j = ticks.length; j > 0; j--) {
                if (t = ticks[j - 1], s = t.markSize, m = t.mark, pos = Math.round(axis.u2p(t.value)) + .5, 
                t.showMark && t.mark) {
                    switch (m) {
                      case "outside":
                        b = left, e = left + s;
                        break;

                      case "inside":
                        b = left - s, e = left;
                        break;

                      case "cross":
                        b = left - s, e = left + s;
                        break;

                      default:
                        b = left, e = left + s;
                    }
                    points = [ [ b, pos ], [ e, pos ] ], this.shadow && this.renderer.shadowRenderer.draw(ctx, points, {
                        lineCap: "butt",
                        lineWidth: 1.5 * this.gridLineWidth,
                        offset: .75 * this.gridLineWidth,
                        fill: !1,
                        closePath: !1
                    }), drawLine(b, pos, e, pos, {
                        strokeStyle: axis.borderColor
                    });
                }
                t = null;
            }
            t0 = null, axis = null, ticks = null;
        }, i = 4; i > 0; i--) name = ax[i - 1], axis = axes[name], ticks = axis._ticks, 
        numticks = ticks.length, this.drawXaxices(name, axis, ticks, numticks);
        for (ax = [ "y3axis", "y4axis", "y5axis", "y6axis", "y7axis", "y8axis", "y9axis", "yMidAxis" ], 
        i = 7; i > 0; i--) axis = axes[ax[i - 1]], ticks = axis._ticks, this.drawYaxices(axis, ticks);
        ctx.restore(), this.shadow && (points = [ [ this._left, this._bottom ], [ this._right, this._bottom ], [ this._right, this._top ] ], 
        this.renderer.shadowRenderer.draw(ctx, points)), 0 !== this.borderWidth && this.drawBorder && (drawLine(this._left, this._top, this._right, this._top, {
            lineCap: "round",
            strokeStyle: axes.x2axis.borderColor,
            lineWidth: axes.x2axis.borderWidth
        }), drawLine(this._right, this._top, this._right, this._bottom, {
            lineCap: "round",
            strokeStyle: axes.y2axis.borderColor,
            lineWidth: axes.y2axis.borderWidth
        }), drawLine(this._right, this._bottom, this._left, this._bottom, {
            lineCap: "round",
            strokeStyle: axes.xaxis.borderColor,
            lineWidth: axes.xaxis.borderWidth
        }), drawLine(this._left, this._bottom, this._left, this._top, {
            lineCap: "round",
            strokeStyle: axes.yaxis.borderColor,
            lineWidth: axes.yaxis.borderWidth
        })), ctx.restore(), ctx = null, axes = null;
    };
}(jQuery);
//# sourceMappingURL=jqplot.canvasGridRenderer.min.js.map