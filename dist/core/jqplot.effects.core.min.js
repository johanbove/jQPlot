!function($) {
    function _normalizeArguments(effect, options, speed, callback) {
        return $.isPlainObject(effect) ? effect : (effect = {
            effect: effect
        }, void 0 === options && (options = {}), $.isFunction(options) && (callback = options, 
        speed = null, options = {}), ("number" === $.type(options) || $.fx.speeds[options]) && (callback = speed, 
        speed = options, options = {}), $.isFunction(speed) && (callback = speed, speed = null), 
        options && $.extend(effect, options), speed = speed || options.duration, effect.duration = $.fx.off ? 0 : "number" == typeof speed ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default, 
        effect.complete = callback || options.complete, effect);
    }
    var backCompat = $.uiBackCompat !== !1;
    $.jqplot.effects = {
        effect: {}
    };
    var dataSpace = "jqplot.storage.";
    $.extend($.jqplot.effects, {
        version: "1.9pre",
        save: function(element, set) {
            for (var i = 0; i < set.length; i++) null !== set[i] && element.data(dataSpace + set[i], element[0].style[set[i]]);
        },
        restore: function(element, set) {
            for (var i = 0; i < set.length; i++) null !== set[i] && element.css(set[i], element.data(dataSpace + set[i]));
        },
        setMode: function(el, mode) {
            return "toggle" === mode && (mode = el.is(":hidden") ? "show" : "hide"), mode;
        },
        createWrapper: function(element) {
            if (element.parent().is(".ui-effects-wrapper")) return element.parent();
            var props = {
                width: element.outerWidth(!0),
                height: element.outerHeight(!0),
                "float": element.css("float")
            }, wrapper = $("<div></div>").addClass("ui-effects-wrapper").css({
                fontSize: "100%",
                background: "transparent",
                border: "none",
                margin: 0,
                padding: 0
            }), size = {
                width: element.width(),
                height: element.height()
            }, active = document.activeElement;
            return element.wrap(wrapper), (element[0] === active || $.contains(element[0], active)) && $(active).focus(), 
            wrapper = element.parent(), "static" === element.css("position") ? (wrapper.css({
                position: "relative"
            }), element.css({
                position: "relative"
            })) : ($.extend(props, {
                position: element.css("position"),
                zIndex: element.css("z-index")
            }), $.each([ "top", "left", "bottom", "right" ], function(i, pos) {
                props[pos] = element.css(pos), isNaN(parseInt(props[pos], 10)) && (props[pos] = "auto");
            }), element.css({
                position: "relative",
                top: 0,
                left: 0,
                right: "auto",
                bottom: "auto"
            })), element.css(size), wrapper.css(props).show();
        },
        removeWrapper: function(element) {
            var active = document.activeElement;
            return element.parent().is(".ui-effects-wrapper") && (element.parent().replaceWith(element), 
            (element[0] === active || $.contains(element[0], active)) && $(active).focus()), 
            element;
        }
    }), $.fn.extend({
        jqplotEffect: function(effect, options, speed, callback) {
            function run(next) {
                function done() {
                    $.isFunction(complete) && complete.call(elem[0]), $.isFunction(next) && next();
                }
                var elem = $(this), complete = args.complete, mode = args.mode;
                (elem.is(":hidden") ? "hide" === mode : "show" === mode) ? done() : effectMethod.call(elem[0], args, done);
            }
            var args = _normalizeArguments.apply(this, arguments), mode = args.mode, queue = args.queue, effectMethod = $.jqplot.effects.effect[args.effect], oldEffectMethod = !effectMethod && backCompat && $.jqplot.effects[args.effect];
            return $.fx.off || !effectMethod && !oldEffectMethod ? mode ? this[mode](args.duration, args.complete) : this.each(function() {
                args.complete && args.complete.call(this);
            }) : effectMethod ? queue === !1 ? this.each(run) : this.queue(queue || "fx", run) : oldEffectMethod.call(this, {
                options: args,
                duration: args.duration,
                callback: args.complete,
                mode: args.mode
            });
        }
    });
}(jQuery);
//# sourceMappingURL=jqplot.effects.core.min.js.map