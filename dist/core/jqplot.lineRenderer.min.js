!function($) {
    function getSteps(d, f) {
        return (3.4182054 + f) * Math.pow(d, -.3534992);
    }
    function tanh(x) {
        var a = (Math.exp(2 * x) - 1) / (Math.exp(2 * x) + 1);
        return a;
    }
    function computeConstrainedSmoothedData(gd) {
        function dxx(x1, x0) {
            return x1 - x0 == 0 ? Math.pow(10, 10) : x1 - x0;
        }
        var smooth = this.renderer.smooth, dim = this.canvas.getWidth(), xp = this._xaxis.series_p2u, yp = this._yaxis.series_p2u, steps = null, dist = gd.length / dim, _smoothedData = [], _smoothedPlotData = [];
        steps = isNaN(parseFloat(smooth)) ? getSteps(dist, .5) : parseFloat(smooth);
        for (var yy = [], xx = [], i = 0, l = gd.length; l > i; i++) yy.push(gd[i][1]), 
        xx.push(gd[i][0]);
        for (var A, B, C, D, nmax = gd.length - 1, num = 1, gdl = gd.length; gdl > num; num++) {
            for (var gxx = [], ggxx = [], j = 0; 2 > j; j++) {
                var i = num - 1 + j;
                0 == i || i == nmax ? gxx[j] = Math.pow(10, 10) : yy[i + 1] - yy[i] == 0 || yy[i] - yy[i - 1] == 0 ? gxx[j] = 0 : (xx[i + 1] - xx[i]) / (yy[i + 1] - yy[i]) + (xx[i] - xx[i - 1]) / (yy[i] - yy[i - 1]) == 0 ? gxx[j] = 0 : (yy[i + 1] - yy[i]) * (yy[i] - yy[i - 1]) < 0 ? gxx[j] = 0 : gxx[j] = 2 / (dxx(xx[i + 1], xx[i]) / (yy[i + 1] - yy[i]) + dxx(xx[i], xx[i - 1]) / (yy[i] - yy[i - 1]));
            }
            1 == num ? gxx[0] = 1.5 * (yy[1] - yy[0]) / dxx(xx[1], xx[0]) - gxx[1] / 2 : num == nmax && (gxx[1] = 1.5 * (yy[nmax] - yy[nmax - 1]) / dxx(xx[nmax], xx[nmax - 1]) - gxx[0] / 2), 
            ggxx[0] = -2 * (gxx[1] + 2 * gxx[0]) / dxx(xx[num], xx[num - 1]) + 6 * (yy[num] - yy[num - 1]) / Math.pow(dxx(xx[num], xx[num - 1]), 2), 
            ggxx[1] = 2 * (2 * gxx[1] + gxx[0]) / dxx(xx[num], xx[num - 1]) - 6 * (yy[num] - yy[num - 1]) / Math.pow(dxx(xx[num], xx[num - 1]), 2), 
            D = 1 / 6 * (ggxx[1] - ggxx[0]) / dxx(xx[num], xx[num - 1]), C = .5 * (xx[num] * ggxx[0] - xx[num - 1] * ggxx[1]) / dxx(xx[num], xx[num - 1]), 
            B = (yy[num] - yy[num - 1] - C * (Math.pow(xx[num], 2) - Math.pow(xx[num - 1], 2)) - D * (Math.pow(xx[num], 3) - Math.pow(xx[num - 1], 3))) / dxx(xx[num], xx[num - 1]), 
            A = yy[num - 1] - B * xx[num - 1] - C * Math.pow(xx[num - 1], 2) - D * Math.pow(xx[num - 1], 3);
            for (var temp, tempx, increment = (xx[num] - xx[num - 1]) / steps, j = 0, l = steps; l > j; j++) temp = [], 
            tempx = xx[num - 1] + j * increment, temp.push(tempx), temp.push(A + B * tempx + C * Math.pow(tempx, 2) + D * Math.pow(tempx, 3)), 
            _smoothedData.push(temp), _smoothedPlotData.push([ xp(temp[0]), yp(temp[1]) ]);
        }
        return _smoothedData.push(gd[i]), _smoothedPlotData.push([ xp(gd[i][0]), yp(gd[i][1]) ]), 
        [ _smoothedData, _smoothedPlotData ];
    }
    function computeHermiteSmoothedData(gd) {
        var t, s, h1, h2, h3, h4, TiX, TiY, Ti1X, Ti1Y, pX, pY, p, min, max, stretch, scale, shift, smooth = this.renderer.smooth, tension = this.renderer.tension, dim = this.canvas.getWidth(), xp = this._xaxis.series_p2u, yp = this._yaxis.series_p2u, steps = null, a = null, a1 = null, a2 = null, slope = null, slope2 = null, temp = null, dist = gd.length / dim, _smoothedData = [], _smoothedPlotData = [];
        steps = isNaN(parseFloat(smooth)) ? getSteps(dist, .5) : parseFloat(smooth), isNaN(parseFloat(tension)) || (tension = parseFloat(tension));
        for (var i = 0, l = gd.length - 1; l > i; i++) for (null === tension ? (slope = Math.abs((gd[i + 1][1] - gd[i][1]) / (gd[i + 1][0] - gd[i][0])), 
        min = .3, max = .6, stretch = (max - min) / 2, scale = 2.5, shift = -1.4, temp = slope / scale + shift, 
        a1 = stretch * tanh(temp) - stretch * tanh(shift) + min, i > 0 && (slope2 = Math.abs((gd[i][1] - gd[i - 1][1]) / (gd[i][0] - gd[i - 1][0]))), 
        temp = slope2 / scale + shift, a2 = stretch * tanh(temp) - stretch * tanh(shift) + min, 
        a = (a1 + a2) / 2) : a = tension, t = 0; steps > t; t++) s = t / steps, h1 = (1 + 2 * s) * Math.pow(1 - s, 2), 
        h2 = s * Math.pow(1 - s, 2), h3 = Math.pow(s, 2) * (3 - 2 * s), h4 = Math.pow(s, 2) * (s - 1), 
        gd[i - 1] ? (TiX = a * (gd[i + 1][0] - gd[i - 1][0]), TiY = a * (gd[i + 1][1] - gd[i - 1][1])) : (TiX = a * (gd[i + 1][0] - gd[i][0]), 
        TiY = a * (gd[i + 1][1] - gd[i][1])), gd[i + 2] ? (Ti1X = a * (gd[i + 2][0] - gd[i][0]), 
        Ti1Y = a * (gd[i + 2][1] - gd[i][1])) : (Ti1X = a * (gd[i + 1][0] - gd[i][0]), Ti1Y = a * (gd[i + 1][1] - gd[i][1])), 
        pX = h1 * gd[i][0] + h3 * gd[i + 1][0] + h2 * TiX + h4 * Ti1X, pY = h1 * gd[i][1] + h3 * gd[i + 1][1] + h2 * TiY + h4 * Ti1Y, 
        p = [ pX, pY ], _smoothedData.push(p), _smoothedPlotData.push([ xp(pX), yp(pY) ]);
        return _smoothedData.push(gd[l]), _smoothedPlotData.push([ xp(gd[l][0]), yp(gd[l][1]) ]), 
        [ _smoothedData, _smoothedPlotData ];
    }
    function postInit(target, data, options) {
        for (var i = 0; i < this.series.length; i++) this.series[i].renderer.constructor == $.jqplot.LineRenderer && this.series[i].highlightMouseOver && (this.series[i].highlightMouseDown = !1);
    }
    function postPlotDraw() {
        this.plugins.lineRenderer && this.plugins.lineRenderer.highlightCanvas && (this.plugins.lineRenderer.highlightCanvas.resetCanvas(), 
        this.plugins.lineRenderer.highlightCanvas = null), this.plugins.lineRenderer.highlightedSeriesIndex = null, 
        this.plugins.lineRenderer.highlightCanvas = new $.jqplot.GenericCanvas(), this.eventCanvas._elem.before(this.plugins.lineRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-lineRenderer-highlight-canvas", this._plotDimensions, this)), 
        this.plugins.lineRenderer.highlightCanvas.setContext(), this.eventCanvas._elem.bind("mouseleave", {
            plot: this
        }, function(ev) {
            unhighlight(ev.data.plot);
        });
    }
    function highlight(plot, sidx, pidx, points) {
        var s = plot.series[sidx], canvas = plot.plugins.lineRenderer.highlightCanvas;
        canvas._ctx.clearRect(0, 0, canvas._ctx.canvas.width, canvas._ctx.canvas.height), 
        s._highlightedPoint = pidx, plot.plugins.lineRenderer.highlightedSeriesIndex = sidx;
        var opts = {
            fillStyle: s.highlightColor
        };
        "line" === s.type && s.renderer.bands.show && (opts.fill = !0, opts.closePath = !0), 
        s.renderer.shapeRenderer.draw(canvas._ctx, points, opts), canvas = null;
    }
    function unhighlight(plot) {
        var canvas = plot.plugins.lineRenderer.highlightCanvas;
        canvas._ctx.clearRect(0, 0, canvas._ctx.canvas.width, canvas._ctx.canvas.height);
        for (var i = 0; i < plot.series.length; i++) plot.series[i]._highlightedPoint = null;
        plot.plugins.lineRenderer.highlightedSeriesIndex = null, plot.target.trigger("jqplotDataUnhighlight"), 
        canvas = null;
    }
    function handleMove(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [ neighbor.seriesIndex, neighbor.pointIndex, neighbor.data ], evt1 = jQuery.Event("jqplotDataMouseOver");
            if (evt1.pageX = ev.pageX, evt1.pageY = ev.pageY, plot.target.trigger(evt1, ins), 
            plot.series[ins[0]].highlightMouseOver && ins[0] != plot.plugins.lineRenderer.highlightedSeriesIndex) {
                var evt = jQuery.Event("jqplotDataHighlight");
                evt.which = ev.which, evt.pageX = ev.pageX, evt.pageY = ev.pageY, plot.target.trigger(evt, ins), 
                highlight(plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);
            }
        } else null == neighbor && unhighlight(plot);
    }
    function handleMouseDown(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [ neighbor.seriesIndex, neighbor.pointIndex, neighbor.data ];
            if (plot.series[ins[0]].highlightMouseDown && ins[0] != plot.plugins.lineRenderer.highlightedSeriesIndex) {
                var evt = jQuery.Event("jqplotDataHighlight");
                evt.which = ev.which, evt.pageX = ev.pageX, evt.pageY = ev.pageY, plot.target.trigger(evt, ins), 
                highlight(plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);
            }
        } else null == neighbor && unhighlight(plot);
    }
    function handleMouseUp(ev, gridpos, datapos, neighbor, plot) {
        var idx = plot.plugins.lineRenderer.highlightedSeriesIndex;
        null != idx && plot.series[idx].highlightMouseDown && unhighlight(plot);
    }
    function handleClick(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [ neighbor.seriesIndex, neighbor.pointIndex, neighbor.data ], evt = jQuery.Event("jqplotDataClick");
            evt.which = ev.which, evt.pageX = ev.pageX, evt.pageY = ev.pageY, plot.target.trigger(evt, ins);
        }
    }
    function handleRightClick(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [ neighbor.seriesIndex, neighbor.pointIndex, neighbor.data ], idx = plot.plugins.lineRenderer.highlightedSeriesIndex;
            null != idx && plot.series[idx].highlightMouseDown && unhighlight(plot);
            var evt = jQuery.Event("jqplotDataRightClick");
            evt.which = ev.which, evt.pageX = ev.pageX, evt.pageY = ev.pageY, plot.target.trigger(evt, ins);
        }
    }
    $.jqplot.LineRenderer = function() {
        this.shapeRenderer = new $.jqplot.ShapeRenderer(), this.shadowRenderer = new $.jqplot.ShadowRenderer();
    }, $.jqplot.LineRenderer.prototype.init = function(options, plot) {
        options = options || {}, this._type = "line", this.renderer.animation = {
            show: !1,
            direction: "left",
            speed: 2500,
            _supported: !0
        }, this.renderer.smooth = !1, this.renderer.tension = null, this.renderer.constrainSmoothing = !0, 
        this.renderer._smoothedData = [], this.renderer._smoothedPlotData = [], this.renderer._hiBandGridData = [], 
        this.renderer._lowBandGridData = [], this.renderer._hiBandSmoothedData = [], this.renderer._lowBandSmoothedData = [], 
        this.renderer.bandData = [], this.renderer.bands = {
            show: !1,
            hiData: [],
            lowData: [],
            color: this.color,
            showLines: !1,
            fill: !0,
            fillColor: null,
            _min: null,
            _max: null,
            interval: "3%"
        };
        var lopts = {
            highlightMouseOver: options.highlightMouseOver,
            highlightMouseDown: options.highlightMouseDown,
            highlightColor: options.highlightColor
        };
        delete options.highlightMouseOver, delete options.highlightMouseDown, delete options.highlightColor, 
        $.extend(!0, this.renderer, options), this.renderer.options = options, this.renderer.bandData.length > 1 && (!options.bands || null == options.bands.show) ? this.renderer.bands.show = !0 : options.bands && null == options.bands.show && null != options.bands.interval && (this.renderer.bands.show = !0), 
        this.fill && (this.renderer.bands.show = !1), this.renderer.bands.show && this.renderer.initBands.call(this, this.renderer.options, plot), 
        this._stack && (this.renderer.smooth = !1);
        var opts = {
            lineJoin: this.lineJoin,
            lineCap: this.lineCap,
            fill: this.fill,
            isarc: !1,
            strokeStyle: this.color,
            fillStyle: this.fillColor,
            lineWidth: this.lineWidth,
            linePattern: this.linePattern,
            closePath: this.fill,
            fillGradient: this.fillGradient,
            fillGradientColor: this.fillGradientColor,
            fillGradientDelay: this.fillGradientDelay
        };
        this.renderer.shapeRenderer.init(opts);
        var shadow_offset = options.shadowOffset;
        null == shadow_offset && (shadow_offset = this.lineWidth > 2.5 ? 1.25 * (1 + .6 * (Math.atan(this.lineWidth / 2.5) / .785398163 - 1)) : 1.25 * Math.atan(this.lineWidth / 2.5) / .785398163);
        var sopts = {
            lineJoin: this.lineJoin,
            lineCap: this.lineCap,
            fill: this.fill,
            isarc: !1,
            angle: this.shadowAngle,
            offset: shadow_offset,
            alpha: this.shadowAlpha,
            depth: this.shadowDepth,
            lineWidth: this.lineWidth,
            linePattern: this.linePattern,
            closePath: this.fill
        };
        if (this.renderer.shadowRenderer.init(sopts), this._areaPoints = [], this._boundingBox = [ [], [] ], 
        !this.isTrendline && this.fill || this.renderer.bands.show) {
            if (this.highlightMouseOver = !0, this.highlightMouseDown = !1, this.highlightColor = null, 
            lopts.highlightMouseDown && null == lopts.highlightMouseOver && (lopts.highlightMouseOver = !1), 
            $.extend(!0, this, {
                highlightMouseOver: lopts.highlightMouseOver,
                highlightMouseDown: lopts.highlightMouseDown,
                highlightColor: lopts.highlightColor
            }), !this.highlightColor) {
                var fc = this.renderer.bands.show ? this.renderer.bands.fillColor : this.fillColor;
                this.highlightColor = $.jqplot.computeHighlightColors(fc);
            }
            this.highlighter && (this.highlighter.show = !1);
        }
        !this.isTrendline && plot && (plot.plugins.lineRenderer = {}, plot.postInitHooks.addOnce(postInit), 
        plot.postDrawHooks.addOnce(postPlotDraw), plot.eventListenerHooks.addOnce("jqplotMouseMove", handleMove), 
        plot.eventListenerHooks.addOnce("jqplotMouseDown", handleMouseDown), plot.eventListenerHooks.addOnce("jqplotMouseUp", handleMouseUp), 
        plot.eventListenerHooks.addOnce("jqplotClick", handleClick), plot.eventListenerHooks.addOnce("jqplotRightClick", handleRightClick));
    }, $.jqplot.LineRenderer.prototype.initBands = function(options, plot) {
        var bd = options.bandData || [], bands = this.renderer.bands;
        bands.hiData = [], bands.lowData = [];
        var data = this.data;
        if (bands._max = null, bands._min = null, 2 == bd.length) if ($.isArray(bd[0][0])) {
            for (var p, bdminidx = 0, bdmaxidx = 0, i = 0, l = bd[0].length; l > i; i++) p = bd[0][i], 
            (null != p[1] && p[1] > bands._max || null == bands._max) && (bands._max = p[1]), 
            (null != p[1] && p[1] < bands._min || null == bands._min) && (bands._min = p[1]);
            for (var i = 0, l = bd[1].length; l > i; i++) p = bd[1][i], (null != p[1] && p[1] > bands._max || null == bands._max) && (bands._max = p[1], 
            bdmaxidx = 1), (null != p[1] && p[1] < bands._min || null == bands._min) && (bands._min = p[1], 
            bdminidx = 1);
            bdmaxidx === bdminidx && (bands.show = !1), bands.hiData = bd[bdmaxidx], bands.lowData = bd[bdminidx];
        } else if (bd[0].length === data.length && bd[1].length === data.length) for (var hi = bd[0][0] > bd[1][0] ? 0 : 1, low = hi ? 0 : 1, i = 0, l = data.length; l > i; i++) bands.hiData.push([ data[i][0], bd[hi][i] ]), 
        bands.lowData.push([ data[i][0], bd[low][i] ]); else bands.show = !1; else if (bd.length > 2 && !$.isArray(bd[0][0])) for (var hi = bd[0][0] > bd[0][1] ? 0 : 1, low = hi ? 0 : 1, i = 0, l = bd.length; l > i; i++) bands.hiData.push([ data[i][0], bd[i][hi] ]), 
        bands.lowData.push([ data[i][0], bd[i][low] ]); else {
            var intrv = bands.interval, a = null, b = null, afunc = null, bfunc = null;
            if ($.isArray(intrv) ? (a = intrv[0], b = intrv[1]) : a = intrv, isNaN(a) ? "%" === a.charAt(a.length - 1) && (afunc = "multiply", 
            a = parseFloat(a) / 100 + 1) : (a = parseFloat(a), afunc = "add"), null !== b && isNaN(b) ? "%" === b.charAt(b.length - 1) && (bfunc = "multiply", 
            b = parseFloat(b) / 100 + 1) : null !== b && (b = parseFloat(b), bfunc = "add"), 
            null !== a) {
                if (null === b && (b = -a, bfunc = afunc, "multiply" === bfunc && (b += 2)), b > a) {
                    var temp = a;
                    a = b, b = temp, temp = afunc, afunc = bfunc, bfunc = temp;
                }
                for (var i = 0, l = data.length; l > i; i++) {
                    switch (afunc) {
                      case "add":
                        bands.hiData.push([ data[i][0], data[i][1] + a ]);
                        break;

                      case "multiply":
                        bands.hiData.push([ data[i][0], data[i][1] * a ]);
                    }
                    switch (bfunc) {
                      case "add":
                        bands.lowData.push([ data[i][0], data[i][1] + b ]);
                        break;

                      case "multiply":
                        bands.lowData.push([ data[i][0], data[i][1] * b ]);
                    }
                }
            } else bands.show = !1;
        }
        for (var hd = bands.hiData, ld = bands.lowData, i = 0, l = hd.length; l > i; i++) (null != hd[i][1] && hd[i][1] > bands._max || null == bands._max) && (bands._max = hd[i][1]);
        for (var i = 0, l = ld.length; l > i; i++) (null != ld[i][1] && ld[i][1] < bands._min || null == bands._min) && (bands._min = ld[i][1]);
        if (null === bands.fillColor) {
            var c = $.jqplot.getColorComponents(bands.color);
            c[3] = .5 * c[3], bands.fillColor = "rgba(" + c[0] + ", " + c[1] + ", " + c[2] + ", " + c[3] + ")";
        }
    }, $.jqplot.LineRenderer.prototype.setGridData = function(plot) {
        var xp = this._xaxis.series_u2p, yp = this._yaxis.series_u2p, data = this._plotData, pdata = this._prevPlotData;
        this.gridData = [], this._prevGridData = [], this.renderer._smoothedData = [], this.renderer._smoothedPlotData = [], 
        this.renderer._hiBandGridData = [], this.renderer._lowBandGridData = [], this.renderer._hiBandSmoothedData = [], 
        this.renderer._lowBandSmoothedData = [];
        for (var bands = this.renderer.bands, hasNull = !1, i = 0, l = data.length; l > i; i++) null != data[i][0] && null != data[i][1] ? this.gridData.push([ xp.call(this._xaxis, data[i][0]), yp.call(this._yaxis, data[i][1]) ]) : null == data[i][0] ? (hasNull = !0, 
        this.gridData.push([ null, yp.call(this._yaxis, data[i][1]) ])) : null == data[i][1] && (hasNull = !0, 
        this.gridData.push([ xp.call(this._xaxis, data[i][0]), null ])), null != pdata[i] && null != pdata[i][0] && null != pdata[i][1] ? this._prevGridData.push([ xp.call(this._xaxis, pdata[i][0]), yp.call(this._yaxis, pdata[i][1]) ]) : null != pdata[i] && null == pdata[i][0] ? this._prevGridData.push([ null, yp.call(this._yaxis, pdata[i][1]) ]) : null != pdata[i] && null != pdata[i][0] && null == pdata[i][1] && this._prevGridData.push([ xp.call(this._xaxis, pdata[i][0]), null ]);
        if (hasNull && (this.renderer.smooth = !1, "line" === this._type && (bands.show = !1)), 
        "line" === this._type && bands.show) {
            for (var i = 0, l = bands.hiData.length; l > i; i++) this.renderer._hiBandGridData.push([ xp.call(this._xaxis, bands.hiData[i][0]), yp.call(this._yaxis, bands.hiData[i][1]) ]);
            for (var i = 0, l = bands.lowData.length; l > i; i++) this.renderer._lowBandGridData.push([ xp.call(this._xaxis, bands.lowData[i][0]), yp.call(this._yaxis, bands.lowData[i][1]) ]);
        }
        if ("line" === this._type && this.renderer.smooth && this.gridData.length > 2) {
            var ret;
            this.renderer.constrainSmoothing ? (ret = computeConstrainedSmoothedData.call(this, this.gridData), 
            this.renderer._smoothedData = ret[0], this.renderer._smoothedPlotData = ret[1], 
            bands.show && (ret = computeConstrainedSmoothedData.call(this, this.renderer._hiBandGridData), 
            this.renderer._hiBandSmoothedData = ret[0], ret = computeConstrainedSmoothedData.call(this, this.renderer._lowBandGridData), 
            this.renderer._lowBandSmoothedData = ret[0]), ret = null) : (ret = computeHermiteSmoothedData.call(this, this.gridData), 
            this.renderer._smoothedData = ret[0], this.renderer._smoothedPlotData = ret[1], 
            bands.show && (ret = computeHermiteSmoothedData.call(this, this.renderer._hiBandGridData), 
            this.renderer._hiBandSmoothedData = ret[0], ret = computeHermiteSmoothedData.call(this, this.renderer._lowBandGridData), 
            this.renderer._lowBandSmoothedData = ret[0]), ret = null);
        }
    }, $.jqplot.LineRenderer.prototype.makeGridData = function(data, plot) {
        var xp = this._xaxis.series_u2p, yp = this._yaxis.series_u2p, gd = [];
        this.renderer._smoothedData = [], this.renderer._smoothedPlotData = [], this.renderer._hiBandGridData = [], 
        this.renderer._lowBandGridData = [], this.renderer._hiBandSmoothedData = [], this.renderer._lowBandSmoothedData = [];
        for (var bands = this.renderer.bands, hasNull = !1, i = 0; i < data.length; i++) null != data[i][0] && null != data[i][1] ? void 0 !== this._xaxis.ticks && "string" == typeof data[i][0] ? gd.push([ xp.call(this._xaxis, this._xaxis.ticks.indexOf(data[i][0]) + 1), yp.call(this._yaxis, data[i][1]) ]) : gd.push([ xp.call(this._xaxis, data[i][0]), yp.call(this._yaxis, data[i][1]) ]) : null == data[i][0] ? (hasNull = !0, 
        gd.push([ null, yp.call(this._yaxis, data[i][1]) ])) : null == data[i][1] && (hasNull = !0, 
        gd.push([ xp.call(this._xaxis, data[i][0]), null ]));
        if (hasNull && (this.renderer.smooth = !1, "line" === this._type && (bands.show = !1)), 
        "line" === this._type && bands.show) {
            for (var i = 0, l = bands.hiData.length; l > i; i++) this.renderer._hiBandGridData.push([ xp.call(this._xaxis, bands.hiData[i][0]), yp.call(this._yaxis, bands.hiData[i][1]) ]);
            for (var i = 0, l = bands.lowData.length; l > i; i++) this.renderer._lowBandGridData.push([ xp.call(this._xaxis, bands.lowData[i][0]), yp.call(this._yaxis, bands.lowData[i][1]) ]);
        }
        if ("line" === this._type && this.renderer.smooth && gd.length > 2) {
            var ret;
            this.renderer.constrainSmoothing ? (ret = computeConstrainedSmoothedData.call(this, gd), 
            this.renderer._smoothedData = ret[0], this.renderer._smoothedPlotData = ret[1], 
            bands.show && (ret = computeConstrainedSmoothedData.call(this, this.renderer._hiBandGridData), 
            this.renderer._hiBandSmoothedData = ret[0], ret = computeConstrainedSmoothedData.call(this, this.renderer._lowBandGridData), 
            this.renderer._lowBandSmoothedData = ret[0]), ret = null) : (ret = computeHermiteSmoothedData.call(this, gd), 
            this.renderer._smoothedData = ret[0], this.renderer._smoothedPlotData = ret[1], 
            bands.show && (ret = computeHermiteSmoothedData.call(this, this.renderer._hiBandGridData), 
            this.renderer._hiBandSmoothedData = ret[0], ret = computeHermiteSmoothedData.call(this, this.renderer._lowBandGridData), 
            this.renderer._lowBandSmoothedData = ret[0]), ret = null);
        }
        return gd;
    }, $.jqplot.LineRenderer.prototype.draw = function(ctx, gd, options, plot) {
        var i, xmin, ymin, xmax, ymax, opts = $.extend(!0, {}, options), shadow = void 0 != opts.shadow ? opts.shadow : this.shadow, showLine = void 0 != opts.showLine ? opts.showLine : this.showLine, fill = void 0 != opts.fill ? opts.fill : this.fill, fillAndStroke = void 0 != opts.fillAndStroke ? opts.fillAndStroke : this.fillAndStroke;
        if (ctx.save(), gd.length) {
            if (showLine) if (fill) {
                if (this.fillToZero) {
                    var negativeColor = this.negativeColor;
                    this.useNegativeColors || (negativeColor = opts.fillStyle);
                    var isnegative = !1, posfs = opts.fillStyle;
                    if (fillAndStroke) var fasgd = gd.slice(0);
                    if (0 != this.index && this._stack) {
                        for (var prev = this._prevGridData, i = prev.length; i > 0; i--) gd.push(prev[i - 1]);
                        shadow && this.renderer.shadowRenderer.draw(ctx, gd, opts), this._areaPoints = gd, 
                        this.renderer.shapeRenderer.draw(ctx, gd, opts);
                    } else {
                        var tempgd = [], pd = this.renderer.smooth ? this.renderer._smoothedPlotData : this._plotData;
                        this._areaPoints = [];
                        var pyzero = this._yaxis.series_u2p(this.fillToValue);
                        this._xaxis.series_u2p(this.fillToValue);
                        if (opts.closePath = !0, "y" == this.fillAxis) {
                            tempgd.push([ gd[0][0], pyzero ]), this._areaPoints.push([ gd[0][0], pyzero ]);
                            for (var i = 0; i < gd.length - 1; i++) if (tempgd.push(gd[i]), this._areaPoints.push(gd[i]), 
                            pd[i][1] * pd[i + 1][1] <= 0) {
                                pd[i][1] < 0 ? (isnegative = !0, opts.fillStyle = negativeColor) : (isnegative = !1, 
                                opts.fillStyle = posfs);
                                var xintercept = gd[i][0] + (gd[i + 1][0] - gd[i][0]) * (pyzero - gd[i][1]) / (gd[i + 1][1] - gd[i][1]);
                                tempgd.push([ xintercept, pyzero ]), this._areaPoints.push([ xintercept, pyzero ]), 
                                shadow && this.renderer.shadowRenderer.draw(ctx, tempgd, opts), this.renderer.shapeRenderer.draw(ctx, tempgd, opts), 
                                tempgd = [ [ xintercept, pyzero ] ];
                            }
                            pd[gd.length - 1][1] < 0 ? (isnegative = !0, opts.fillStyle = negativeColor) : (isnegative = !1, 
                            opts.fillStyle = posfs), tempgd.push(gd[gd.length - 1]), this._areaPoints.push(gd[gd.length - 1]), 
                            tempgd.push([ gd[gd.length - 1][0], pyzero ]), this._areaPoints.push([ gd[gd.length - 1][0], pyzero ]);
                        }
                        shadow && this.renderer.shadowRenderer.draw(ctx, tempgd, opts), this.renderer.shapeRenderer.draw(ctx, tempgd, opts);
                    }
                } else {
                    if (fillAndStroke) var fasgd = gd.slice(0);
                    if (0 != this.index && this._stack) for (var prev = this._prevGridData, i = prev.length; i > 0; i--) gd.push(prev[i - 1]); else {
                        var gridymin = ctx.canvas.height;
                        gd.unshift([ gd[0][0], gridymin ]);
                        var len = gd.length;
                        gd.push([ gd[len - 1][0], gridymin ]);
                    }
                    this._areaPoints = gd, shadow && this.renderer.shadowRenderer.draw(ctx, gd, opts), 
                    this.renderer.shapeRenderer.draw(ctx, gd, opts);
                }
                if (fillAndStroke) {
                    var fasopts = $.extend(!0, {}, opts, {
                        fill: !1,
                        closePath: !1
                    });
                    if (this.renderer.shapeRenderer.draw(ctx, fasgd, fasopts), this.markerRenderer.show) for (this.renderer.smooth && (fasgd = this.gridData), 
                    i = 0; i < fasgd.length; i++) this.markerRenderer.draw(fasgd[i][0], fasgd[i][1], ctx, opts.markerOptions);
                }
            } else {
                if (this.renderer.bands.show) {
                    var bdat, bopts = $.extend(!0, {}, opts);
                    this.renderer.bands.showLines && (bdat = this.renderer.smooth ? this.renderer._hiBandSmoothedData : this.renderer._hiBandGridData, 
                    this.renderer.shapeRenderer.draw(ctx, bdat, opts), bdat = this.renderer.smooth ? this.renderer._lowBandSmoothedData : this.renderer._lowBandGridData, 
                    this.renderer.shapeRenderer.draw(ctx, bdat, bopts)), this.renderer.bands.fill && (bdat = this.renderer.smooth ? this.renderer._hiBandSmoothedData.concat(this.renderer._lowBandSmoothedData.reverse()) : this.renderer._hiBandGridData.concat(this.renderer._lowBandGridData.reverse()), 
                    this._areaPoints = bdat, bopts.closePath = !0, bopts.fill = !0, bopts.fillStyle = this.renderer.bands.fillColor, 
                    this.renderer.shapeRenderer.draw(ctx, bdat, bopts));
                }
                shadow && this.renderer.shadowRenderer.draw(ctx, gd, opts), this.renderer.shapeRenderer.draw(ctx, gd, opts);
            }
            var xmin = xmax = ymin = ymax = null;
            for (i = 0; i < this._areaPoints.length; i++) {
                var p = this._areaPoints[i];
                (xmin > p[0] || null == xmin) && (xmin = p[0]), (ymax < p[1] || null == ymax) && (ymax = p[1]), 
                (xmax < p[0] || null == xmax) && (xmax = p[0]), (ymin > p[1] || null == ymin) && (ymin = p[1]);
            }
            if ("line" === this.type && this.renderer.bands.show && (ymax = this._yaxis.series_u2p(this.renderer.bands._min), 
            ymin = this._yaxis.series_u2p(this.renderer.bands._max)), this._boundingBox = [ [ xmin, ymax ], [ xmax, ymin ] ], 
            this.markerRenderer.show && !fill) for (this.renderer.smooth && (gd = this.gridData), 
            i = 0; i < gd.length; i++) null != gd[i][0] && null != gd[i][1] && this.markerRenderer.draw(gd[i][0], gd[i][1], ctx, opts.markerOptions);
        }
        ctx.restore();
    }, $.jqplot.LineRenderer.prototype.drawShadow = function(ctx, gd, options) {};
}(jQuery);
//# sourceMappingURL=jqplot.lineRenderer.min.js.map