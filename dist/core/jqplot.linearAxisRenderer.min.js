!function($) {
    "use strict";
    Function.prototype.bind || (Function.prototype.bind = function(oThis) {
        if ("function" != typeof this) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, FNOP = function() {}, fBound = function() {
            return fToBind.apply(this instanceof FNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        return FNOP.prototype = this.prototype, fBound.prototype = new FNOP(), fBound;
    });
    var RendererExistingTicks, RendererTicks;
    $.jqplot.LinearAxisRenderer = function() {}, $.jqplot.LinearAxisRenderer.prototype.init = function(options) {
        this.breakPoints = null, this.breakTickLabel = "&asymp;", this.drawBaseline = "undefined" != typeof this.drawBaseline ? this.drawBaseline : !0, 
        this.baselineWidth = null, this.baselineColor = null, this.forceTickAt0 = !1, this.forceTickAt100 = !1, 
        this.tickInset = 0, this.minorTicks = 0, this.alignTicks = !1, this._autoFormatString = "", 
        this._overrideFormatString = !1, this._scalefact = 1, this.labelFullHoursOnly = !1, 
        $.extend(!0, this, options), this.breakPoints && ($.isArray(this.breakPoints) ? (this.breakPoints.length < 2 || this.breakPoints[1] <= this.breakPoints[0]) && (this.breakPoints = null) : this.breakPoints = null), 
        null !== this.numberTicks && this.numberTicks < 2 && (this.numberTicks = 2), this.resetDataBounds();
    }, $.jqplot.LinearAxisRenderer.prototype.draw = function(ctx, plot) {
        var dim, t, tick, elem, i;
        if (!this.show) return this._elem;
        for (this.renderer.createTicks.call(this, plot), dim = 0, this._elem && (this._elem.emptyForce(), 
        this._elem = null), this._elem = $(document.createElement("div")).addClass("jqplot-axis jqplot-" + this.name).css("position", "absolute"), 
        "xaxis" === this.name || "x2axis" === this.name ? this._elem.width(this._plotDimensions.width) : this._elem.height(this._plotDimensions.height), 
        this.labelOptions.axis = this.name, this._label = new this.labelRenderer(this.labelOptions), 
        this._label.show && (elem = this._label.draw(ctx, plot), elem.appendTo(this._elem), 
        elem = null), t = this._ticks, i = 0; i < t.length; i++) tick = t[i], tick.show && tick.showLabel && (!tick.isMinorTick || this.showMinorTicks) && this._elem.append(tick.draw(ctx, plot));
        return tick = null, t = null, this._elem;
    }, $.jqplot.LinearAxisRenderer.prototype.reset = function() {
        this.min = this._options.min, this.max = this._options.max, this.tickInterval = this._options.tickInterval, 
        this.numberTicks = this._options.numberTicks, this._autoFormatString = "", this._overrideFormatString && this.tickOptions && this.tickOptions.formatString && (this.tickOptions.formatString = "");
    }, $.jqplot.LinearAxisRenderer.prototype.set = function() {
        var dim, temp, w, h, lshow, t, tick, i;
        if (dim = 0, w = 0, h = 0, lshow = null === this._label ? !1 : this._label.show, 
        this.show) {
            for (t = this._ticks, i = 0; i < t.length; i++) tick = t[i], tick._breakTick || !tick.show || !tick.showLabel || tick.isMinorTick && !this.showMinorTicks || (temp = "xaxis" === this.name || "x2axis" === this.name ? tick._elem.outerHeight(!0) : tick._elem.outerWidth(!0), 
            temp > dim && (dim = temp));
            tick = null, t = null, lshow && (w = this._label._elem.outerWidth(!0), h = this._label._elem.outerHeight(!0)), 
            "xaxis" === this.name ? (dim += h, this._elem.css({
                height: dim + "px",
                left: "0px",
                bottom: "0px"
            })) : "x2axis" === this.name ? (dim += h, this._elem.css({
                height: dim + "px",
                left: "0px",
                top: "0px"
            })) : "yaxis" === this.name ? (dim += w, this._elem.css({
                width: dim + "px",
                left: "0px",
                top: "0px"
            }), lshow && this._label.constructor === $.jqplot.AxisLabelRenderer && this._label._elem.css("width", w + "px")) : (dim += w, 
            this._elem.css({
                width: dim + "px",
                right: "0px",
                top: "0px"
            }), lshow && this._label.constructor === $.jqplot.AxisLabelRenderer && this._label._elem.css("width", w + "px"));
        }
    }, RendererExistingTicks = function(userTicks) {
        var ut, t, i, l = userTicks.length;
        for (i = 0; l > i; i++) ut = userTicks[i], t = new this.tickRenderer(this.tickOptions), 
        $.isArray(ut) ? (t.value = ut[0], this.breakPoints ? ut[0] === this.breakPoints[0] ? (t.label = this.breakTickLabel, 
        t._breakTick = !0, t.showGridline = !1, t.showMark = !1) : ut[0] > this.breakPoints[0] && ut[0] <= this.breakPoints[1] ? (t.show = !1, 
        t.showGridline = !1, t.label = ut[1]) : t.label = ut[1] : t.label = ut[1], t.setTick(ut[0], this.name), 
        this._ticks.push(t)) : $.isPlainObject(ut) ? ($.extend(!0, t, ut), t.axis = this.name, 
        this._ticks.push(t)) : (t.value = ut, this.breakPoints && (ut === this.breakPoints[0] ? (t.label = this.breakTickLabel, 
        t._breakTick = !0, t.showGridline = !1, t.showMark = !1) : ut > this.breakPoints[0] && ut <= this.breakPoints[1] && (t.show = !1, 
        t.showGridline = !1)), t.setTick(ut, this.name), this._ticks.push(t));
        this.numberTicks = userTicks.length, this.min = this._ticks[0].value, this.max = this._ticks[this.numberTicks - 1].value, 
        this.tickInterval = (this.max - this.min) / (this.numberTicks - 1);
    }, RendererTicks = function(dim, db, plot) {
        var _numberTicks, min, max, adj, range, ret, tt, t, to, i, j, scaler = null, drawTicks = null, doCompleteAutoscaling = function(min, max, range, numberTicks) {
            var keepMin, keepMax, tumin, tumax;
            this.forceTickAt0 && (min > 0 && (min = 0), 0 > max && (max = 0)), this.forceTickAt100 && (min > 100 && (min = 100), 
            100 > max && (max = 100)), keepMin = !1, keepMax = !1, null !== this.min ? keepMin = !0 : null !== this.max && (keepMax = !0), 
            ret = $.jqplot.LinearTickGenerator(min, max, this._scalefact, numberTicks, keepMin, keepMax), 
            tumin = null !== this.min ? min : min + range * (this.padMin - 1), tumax = null !== this.max ? max : max - range * (this.padMax - 1), 
            (tumin > min || max > tumax) && (tumin = null !== this.min ? min : min - range * (this.padMin - 1), 
            tumax = null !== this.max ? max : max + range * (this.padMax - 1), ret = $.jqplot.LinearTickGenerator(tumin, tumax, this._scalefact, numberTicks, keepMin, keepMax)), 
            this.min = ret[0], this.max = ret[1], this.numberTicks = ret[2], this._autoFormatString = ret[3], 
            this.tickInterval = ret[4];
        }, doAutoScale = function(min, max, range, dim) {
            var rrange, ti, margin, forceMinZero, forceZeroLine, intervals, i, j, s, faname, vals, vmin, vmax, dp, userMin, ntmin, ntmax, sf, fstr, temp, seriesLen = this._series.length;
            for (forceMinZero = !1, forceZeroLine = !1, intervals = {
                min: null,
                max: null,
                average: null,
                stddev: null
            }, i = 0; seriesLen > i; i++) if (s = this._series[i], faname = "x" === s.fillAxis ? s._xaxis.name : s._yaxis.name, 
            this.name === faname) {
                for (vals = s._plotValues[s.fillAxis], vmin = vals[0], vmax = vals[0], j = 1; j < vals.length; j++) vals[j] < vmin ? vmin = vals[j] : vals[j] > vmax && (vmax = vals[j]);
                dp = (vmax - vmin) / vmax, s.renderer.constructor === $.jqplot.BarRenderer ? vmin >= 0 && (s.fillToZero || dp > .1) ? forceMinZero = !0 : (forceMinZero = !1, 
                forceZeroLine = s.fill && s.fillToZero && 0 > vmin && vmax > 0 ? !0 : !1) : s.fill ? vmin >= 0 && (s.fillToZero || dp > .1) ? forceMinZero = !0 : 0 > vmin && vmax > 0 && s.fillToZero ? (forceMinZero = !1, 
                forceZeroLine = !0) : (forceMinZero = !1, forceZeroLine = !1) : 0 > vmin && (forceMinZero = !1);
            }
            forceMinZero ? (this.numberTicks = 2 + Math.ceil((dim - (this.tickSpacing - 1)) / this.tickSpacing), 
            this.min = 0, userMin = 0, ti = max / (this.numberTicks - 1), temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti) / Math.LN10))), 
            ti / temp === parseInt(ti / temp, 10) && (ti += temp), this.tickInterval = Math.ceil(ti / temp) * temp, 
            this.max = this.tickInterval * (this.numberTicks - 1)) : forceZeroLine ? (this.numberTicks = 2 + Math.ceil((dim - (this.tickSpacing - 1)) / this.tickSpacing), 
            ntmin = Math.ceil(Math.abs(min) / range * (this.numberTicks - 1)), ntmax = this.numberTicks - 1 - ntmin, 
            ti = Math.max(Math.abs(min / ntmin), Math.abs(max / ntmax)), temp = Math.pow(10, Math.abs(Math.floor(Math.log(ti) / Math.LN10))), 
            this.tickInterval = Math.ceil(ti / temp) * temp, this.max = this.tickInterval * ntmax, 
            this.min = -this.tickInterval * ntmin) : (null === this.numberTicks && (this.tickInterval ? this.numberTicks = 3 + Math.ceil(range / this.tickInterval) : this.numberTicks = 2 + Math.ceil((dim - (this.tickSpacing - 1)) / this.tickSpacing)), 
            null === this.tickInterval ? (ti = range / (this.numberTicks - 1), temp = 1 > ti ? Math.pow(10, Math.abs(Math.floor(Math.log(ti) / Math.LN10))) : 1, 
            this.tickInterval = Math.ceil(ti * temp * this.pad) / temp) : temp = 1 / this.tickInterval, 
            rrange = this.tickInterval * (this.numberTicks - 1), margin = (rrange - range) / 2, 
            null === this.min && (this.min = Math.floor(temp * (min - margin)) / temp), null === this.max && (this.max = this.min + rrange)), 
            sf = $.jqplot.getSignificantFigures(this.tickInterval), sf.digitsLeft >= sf.significantDigits ? fstr = "%d" : (temp = Math.max(0, 5 - sf.digitsLeft), 
            temp = Math.min(temp, sf.digitsRight), fstr = "%." + temp + "f"), this._autoFormatString = fstr;
        }, doDefaultScale = function(min, max, range, dim) {
            var rmin, rmax, sf, fstr, temp;
            rmin = null !== this.min ? this.min : min - range * (this.padMin - 1), rmax = null !== this.max ? this.max : max + range * (this.padMax - 1), 
            range = rmax - rmin, null === this.numberTicks && (null !== this.tickInterval ? this.numberTicks = Math.ceil((rmax - rmin) / this.tickInterval) + 1 : dim > 100 ? this.numberTicks = parseInt(3 + (dim - 100) / 75, 10) : this.numberTicks = 2), 
            null === this.tickInterval && (this.tickInterval = range / (this.numberTicks - 1)), 
            null === this.max && (rmax = rmin + this.tickInterval * (this.numberTicks - 1)), 
            null === this.min && (rmin = rmax - this.tickInterval * (this.numberTicks - 1)), 
            sf = $.jqplot.getSignificantFigures(this.tickInterval), sf.digitsLeft >= sf.significantDigits ? fstr = "%d" : (temp = Math.max(0, 5 - sf.digitsLeft), 
            temp = Math.min(temp, sf.digitsRight), fstr = "%." + temp + "f"), this._autoFormatString = fstr, 
            this.min = rmin, this.max = rmax;
        }, DrawTicks = function() {
            var range, temptick, fs, precision, m, fact, n, userMin, userMax, userNT, userTI;
            userMin = this.min, userMax = this.max, userNT = this.numberTicks, userTI = this.tickInterval, 
            range = this.max - this.min, temptick = new this.tickRenderer(this.tickOptions), 
            fs = temptick.formatString || $.jqplot.config.defaultTickFormatString, fs = fs.match($.jqplot.sprintf.regex)[0], 
            precision = 0, fs && (fs.search(/[fFeEgGpP]/) > -1 ? (m = fs.match(/\%\.(\d{0,})?[eEfFgGpP]/), 
            precision = m ? parseInt(m[1], 10) : 6) : fs.search(/[di]/) > -1 && (precision = 0), 
            fact = Math.pow(10, -precision), this.tickInterval > fact || null === userNT && null === userTI && (this.tickInterval = fact, 
            null === userMax && null === userMin ? (this.min = Math.floor(this._dataBounds.min / fact) * fact, 
            this.min === this._dataBounds.min && (this.min = this._dataBounds.min - this.tickInterval), 
            this.max = Math.ceil(this._dataBounds.max / fact) * fact, this.max === this._dataBounds.max && (this.max = this._dataBounds.max + this.tickInterval), 
            n = (this.max - this.min) / this.tickInterval, n = n.toFixed(11), n = Math.ceil(n), 
            this.numberTicks = n + 1) : null === userMax ? (n = (this._dataBounds.max - this.min) / this.tickInterval, 
            n = n.toFixed(11), this.numberTicks = Math.ceil(n) + 2, this.max = this.min + this.tickInterval * (this.numberTicks - 1)) : null === userMin ? (n = (this.max - this._dataBounds.min) / this.tickInterval, 
            n = n.toFixed(11), this.numberTicks = Math.ceil(n) + 2, this.min = this.max - this.tickInterval * (this.numberTicks - 1)) : (this.numberTicks = Math.ceil((userMax - userMin) / this.tickInterval) + 1, 
            this.min = Math.floor(userMin * Math.pow(10, precision)) / Math.pow(10, precision), 
            this.max = Math.ceil(userMax * Math.pow(10, precision)) / Math.pow(10, precision), 
            this.numberTicks = Math.ceil((this.max - this.min) / this.tickInterval) + 1)));
        };
        for (_numberTicks = this.numberTicks, this.alignTicks && ("x2axis" === this.name && plot.axes.xaxis.show ? _numberTicks = plot.axes.xaxis.numberTicks : "y" === this.name.charAt(0) && "yaxis" !== this.name && "yMidAxis" !== this.name && plot.axes.yaxis.show && (_numberTicks = plot.axes.yaxis.numberTicks)), 
        min = null !== this.min ? this.min : db.min, max = null !== this.max ? this.max : db.max, 
        min === max && (adj = .05, min > 0 && (adj = Math.max(Math.log(min) / Math.LN10, .05)), 
        min -= adj, max += adj), range = max - min, null !== this.tickOptions && this.tickOptions.formatString || (this._overrideFormatString = !0), 
        null !== this.min && (null !== this.max || null !== this.tickInterval) || this.autoscale ? (min === max && (adj = .05, 
        min > 0 && (adj = Math.max(Math.log(min) / Math.LN10, .05)), min -= adj, max += adj), 
        this.autoscale && null === this.min && null === this.max ? (scaler = doAutoScale.bind(this))(min, max, range, dim) : (scaler = doDefaultScale.bind(this))(min, max, range, dim), 
        this.renderer.constructor === $.jqplot.LinearAxisRenderer && "" === this._autoFormatString && (drawTicks = DrawTicks.bind(this))()) : (scaler = doCompleteAutoscaling.bind(this))(min, max, range, _numberTicks), 
        this._overrideFormatString && "" !== this._autoFormatString && (this.tickOptions = this.tickOptions || {}, 
        this.tickOptions.formatString = this._autoFormatString), i = 0; i < this.numberTicks; i++) {
            if (tt = this.min + i * this.tickInterval, t = new this.tickRenderer(this.tickOptions), 
            t.setTick(tt, this.name), this._ticks.push(t), i < this.numberTicks - 1) for (j = 0; j < this.minorTicks; j++) tt += this.tickInterval / (this.minorTicks + 1), 
            to = $.extend(!0, {}, this.tickOptions, {
                name: this.name,
                value: tt,
                label: "",
                isMinorTick: !0
            }), t = new this.tickRenderer(to), this._ticks.push(t);
            t = null;
        }
    }, $.jqplot.LinearAxisRenderer.prototype.createTicks = function(plot) {
        var ticks, userTicks, name, db, dim, threshold, renderTicks = null;
        ticks = this._ticks, userTicks = this.ticks, name = this.name, db = this._dataBounds, 
        dim = "x" === this.name.charAt(0) ? this._plotDimensions.width : this._plotDimensions.height, 
        threshold = 30, this._scalefact = (Math.max(dim, threshold + 1) - threshold) / 300, 
        userTicks.length ? (renderTicks = RendererExistingTicks.bind(this))(userTicks) : (dim = "xaxis" === name || "x2axis" === name ? this._plotDimensions.width : this._plotDimensions.height, 
        (renderTicks = RendererTicks.bind(this))(dim, db, plot)), this.tickInset && (this.min = this.min - this.tickInset * this.tickInterval, 
        this.max = this.max + this.tickInset * this.tickInterval), ticks = null;
    }, $.jqplot.LinearAxisRenderer.prototype.resetTickValues = function(opts) {
        var t, i;
        if ($.isArray(opts) && opts.length === this._ticks.length) {
            for (i = 0; i < opts.length; i++) t = this._ticks[i], t.value = opts[i], t.label = t.formatter(t.formatString, opts[i]), 
            t.label = t.prefix + t.label, t._elem.html(t.label);
            t = null, this.min = $.jqplot.arrayMin(opts), this.max = $.jqplot.arrayMax(opts), 
            this.pack();
        }
    }, $.jqplot.LinearAxisRenderer.prototype.pack = function(pos, offsets) {
        pos = pos || {}, offsets = offsets || this._offsets;
        var ticks, max, min, offmax, offmin, lshow, p, pixellength, unitlength, i, t, shim, temp, val, w, h;
        ticks = this._ticks, max = this.max, min = this.min, offmax = offsets.max, offmin = offsets.min, 
        lshow = null === this._label ? !1 : this._label.show;
        for (p in pos) pos.hasOwnProperty(p) && this._elem.css(p, pos[p]);
        if (this._offsets = offsets, pixellength = offmax - offmin, unitlength = max - min, 
        this.breakPoints ? (unitlength = unitlength - this.breakPoints[1] + this.breakPoints[0], 
        this.p2u = function(p) {
            return (p - offmin) * unitlength / pixellength + min;
        }, this.u2p = function(u) {
            return u > this.breakPoints[0] && u < this.breakPoints[1] && (u = this.breakPoints[0]), 
            u <= this.breakPoints[0] ? (u - min) * pixellength / unitlength + offmin : (u - this.breakPoints[1] + this.breakPoints[0] - min) * pixellength / unitlength + offmin;
        }, "x" === this.name.charAt(0) ? (this.series_u2p = function(u) {
            return u > this.breakPoints[0] && u < this.breakPoints[1] && (u = this.breakPoints[0]), 
            u <= this.breakPoints[0] ? (u - min) * pixellength / unitlength : (u - this.breakPoints[1] + this.breakPoints[0] - min) * pixellength / unitlength;
        }, this.series_p2u = function(p) {
            return p * unitlength / pixellength + min;
        }) : (this.series_u2p = function(u) {
            return u > this.breakPoints[0] && u < this.breakPoints[1] && (u = this.breakPoints[0]), 
            u >= this.breakPoints[1] ? (u - max) * pixellength / unitlength : (u + this.breakPoints[1] - this.breakPoints[0] - max) * pixellength / unitlength;
        }, this.series_p2u = function(p) {
            return p * unitlength / pixellength + max;
        })) : (this.p2u = function(p) {
            return (p - offmin) * unitlength / pixellength + min;
        }, this.u2p = function(u) {
            return (u - min) * pixellength / unitlength + offmin;
        }, "xaxis" === this.name || "x2axis" === this.name ? (this.series_u2p = function(u) {
            return (u - min) * pixellength / unitlength;
        }, this.series_p2u = function(p) {
            return p * unitlength / pixellength + min;
        }) : (this.series_u2p = function(u) {
            return (u - max) * pixellength / unitlength;
        }, this.series_p2u = function(p) {
            return p * unitlength / pixellength + max;
        })), !this.show) return void (ticks = null);
        if ("xaxis" === this.name || "x2axis" === this.name) {
            for (i = 0; i < ticks.length; i++) if (t = ticks[i], t.show && t.showLabel) {
                if (t.constructor === $.jqplot.CanvasAxisTickRenderer && t.angle) switch (temp = "xaxis" === this.name ? 1 : -1, 
                t.labelPosition) {
                  case "auto":
                    shim = temp * t.angle < 0 ? -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2 : -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                    break;

                  case "end":
                    shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                    break;

                  case "start":
                    shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                    break;

                  case "middle":
                    shim = -t.getWidth() / 2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                    break;

                  default:
                    shim = -t.getWidth() / 2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                } else shim = -t.getWidth() / 2;
                val = this.u2p(t.value) + shim + "px", t._elem.css("left", val), t.pack();
            }
            lshow && (w = this._label._elem.outerWidth(!0), this._label._elem.css("left", offmin + pixellength / 2 - w / 2 + "px"), 
            "xaxis" === this.name ? this._label._elem.css("bottom", "0px") : this._label._elem.css("top", "0px"), 
            this._label.pack());
        } else {
            for (i = 0; i < ticks.length; i++) if (t = ticks[i], t.show && t.showLabel) {
                if (t.constructor === $.jqplot.CanvasAxisTickRenderer && t.angle) switch (temp = "yaxis" === this.name ? 1 : -1, 
                t.labelPosition) {
                  case "auto":
                  case "end":
                    shim = temp * t.angle < 0 ? -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2 : -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                    break;

                  case "start":
                    shim = t.angle > 0 ? -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2 : -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                    break;

                  case "middle":
                    shim = -t.getHeight() / 2;
                    break;

                  default:
                    shim = -t.getHeight() / 2;
                } else shim = -t.getHeight() / 2;
                val = this.u2p(t.value) + shim + "px", t._elem.css("top", val), t.pack();
            }
            lshow && (h = this._label._elem.outerHeight(!0), this._label._elem.css("top", offmax - pixellength / 2 - h / 2 + "px"), 
            "yaxis" === this.name ? this._label._elem.css("left", "0px") : this._label._elem.css("right", "0px"), 
            this._label.pack());
        }
        ticks = null;
    };
}(jQuery);
//# sourceMappingURL=jqplot.linearAxisRenderer.min.js.map