!function($) {
    $.jqplot.sprintf = function() {
        function pad(str, len, chr, leftJustify) {
            var padding = str.length >= len ? "" : Array(1 + len - str.length >>> 0).join(chr);
            return leftJustify ? str + padding : padding + str;
        }
        function thousand_separate(value) {
            for (var value_str = new String(value), i = 10; i > 0 && value_str != (value_str = value_str.replace(/^(\d+)(\d{3})/, "$1" + $.jqplot.sprintf.thousandsSeparator + "$2")); i--) ;
            return value_str;
        }
        function justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace) {
            var diff = minWidth - value.length;
            if (diff > 0) {
                var spchar = " ";
                htmlSpace && (spchar = "&nbsp;"), value = leftJustify || !zeroPad ? pad(value, minWidth, spchar, leftJustify) : value.slice(0, prefix.length) + pad("", diff, "0", !0) + value.slice(prefix.length);
            }
            return value;
        }
        function formatBaseX(value, base, prefix, leftJustify, minWidth, precision, zeroPad, htmlSpace) {
            var number = value >>> 0;
            return prefix = prefix && number && {
                "2": "0b",
                "8": "0",
                "16": "0x"
            }[base] || "", value = prefix + pad(number.toString(base), precision || 0, "0", !1), 
            justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace);
        }
        function formatString(value, leftJustify, minWidth, precision, zeroPad, htmlSpace) {
            return null != precision && (value = value.slice(0, precision)), justify(value, "", leftJustify, minWidth, zeroPad, htmlSpace);
        }
        var a = arguments, i = 0, format = a[i++];
        return format.replace($.jqplot.sprintf.regex, function(substring, valueIndex, flags, minWidth, _, precision, type) {
            if ("%%" == substring) return "%";
            for (var leftJustify = !1, positivePrefix = "", zeroPad = !1, prefixBaseX = !1, htmlSpace = !1, thousandSeparation = !1, j = 0; flags && j < flags.length; j++) switch (flags.charAt(j)) {
              case " ":
                positivePrefix = " ";
                break;

              case "+":
                positivePrefix = "+";
                break;

              case "-":
                leftJustify = !0;
                break;

              case "0":
                zeroPad = !0;
                break;

              case "#":
                prefixBaseX = !0;
                break;

              case "&":
                htmlSpace = !0;
                break;

              case "'":
                thousandSeparation = !0;
            }
            if (minWidth = minWidth ? "*" == minWidth ? +a[i++] : "*" == minWidth.charAt(0) ? +a[minWidth.slice(1, -1)] : +minWidth : 0, 
            0 > minWidth && (minWidth = -minWidth, leftJustify = !0), !isFinite(minWidth)) throw new Error("$.jqplot.sprintf: (minimum-)width must be finite");
            precision = precision ? "*" == precision ? +a[i++] : "*" == precision.charAt(0) ? +a[precision.slice(1, -1)] : +precision : "fFeE".indexOf(type) > -1 ? 6 : "d" == type ? 0 : void 0;
            var value = valueIndex ? a[valueIndex.slice(0, -1)] : a[i++];
            switch (type) {
              case "s":
                return null == value ? "" : formatString(String(value), leftJustify, minWidth, precision, zeroPad, htmlSpace);

              case "c":
                return formatString(String.fromCharCode(+value), leftJustify, minWidth, precision, zeroPad, htmlSpace);

              case "b":
                return formatBaseX(value, 2, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);

              case "o":
                return formatBaseX(value, 8, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);

              case "x":
                return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);

              case "X":
                return formatBaseX(value, 16, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace).toUpperCase();

              case "u":
                return formatBaseX(value, 10, prefixBaseX, leftJustify, minWidth, precision, zeroPad, htmlSpace);

              case "i":
                var number = parseInt(+value, 10);
                if (isNaN(number)) return "";
                var prefix = 0 > number ? "-" : positivePrefix, number_str = thousandSeparation ? thousand_separate(String(Math.abs(number))) : String(Math.abs(number));
                return value = prefix + pad(number_str, precision, "0", !1), justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace);

              case "d":
                var number = Math.round(+value);
                if (isNaN(number)) return "";
                var prefix = 0 > number ? "-" : positivePrefix, number_str = thousandSeparation ? thousand_separate(String(Math.abs(number))) : String(Math.abs(number));
                return value = prefix + pad(number_str, precision, "0", !1), justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace);

              case "e":
              case "E":
              case "f":
              case "F":
              case "g":
              case "G":
                var number = +value;
                if (isNaN(number)) return "";
                var prefix = 0 > number ? "-" : positivePrefix, method = [ "toExponential", "toFixed", "toPrecision" ]["efg".indexOf(type.toLowerCase())], textTransform = [ "toString", "toUpperCase" ]["eEfFgG".indexOf(type) % 2], number_str = Math.abs(number)[method](precision), parts = number_str.toString().split(".");
                parts[0] = thousandSeparation ? thousand_separate(parts[0]) : parts[0], number_str = parts.join($.jqplot.sprintf.decimalMark), 
                value = prefix + number_str;
                var justified = justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace)[textTransform]();
                return justified;

              case "p":
              case "P":
                var number = +value;
                if (isNaN(number)) return "";
                var prefix = 0 > number ? "-" : positivePrefix, parts = String(Number(Math.abs(number)).toExponential()).split(/e|E/), sd = -1 != parts[0].indexOf(".") ? parts[0].length - 1 : String(number).length, zeros = parts[1] < 0 ? -parts[1] - 1 : 0;
                if (Math.abs(number) < 1) value = precision >= sd + zeros ? prefix + Math.abs(number).toPrecision(sd) : precision - 1 >= sd ? prefix + Math.abs(number).toExponential(sd - 1) : prefix + Math.abs(number).toExponential(precision - 1); else {
                    var prec = precision >= sd ? sd : precision;
                    value = prefix + Math.abs(number).toPrecision(prec);
                }
                var textTransform = [ "toString", "toUpperCase" ]["pP".indexOf(type) % 2];
                return justify(value, prefix, leftJustify, minWidth, zeroPad, htmlSpace)[textTransform]();

              case "n":
                return "";

              default:
                return substring;
            }
        });
    }, $.jqplot.sprintf.thousandsSeparator = ",", $.jqplot.sprintf.decimalMark = ".", 
    $.jqplot.sprintf.regex = /%%|%(\d+\$)?([-+#0&\' ]*)(\*\d+\$|\*|\d+)?(\.(\*\d+\$|\*|\d+))?([nAscboxXuidfegpEGP])/g, 
    $.jqplot.getSignificantFigures = function(number) {
        var parts = String(Number(Math.abs(number)).toExponential()).split(/e|E/), sd = -1 != parts[0].indexOf(".") ? parts[0].length - 1 : parts[0].length, zeros = parts[1] < 0 ? -parts[1] - 1 : 0, expn = parseInt(parts[1], 10), dleft = expn + 1 > 0 ? expn + 1 : 0, dright = dleft >= sd ? 0 : sd - expn - 1;
        return {
            significantDigits: sd,
            digitsLeft: dleft,
            digitsRight: dright,
            zeros: zeros,
            exponent: expn
        };
    }, $.jqplot.getPrecision = function(number) {
        return $.jqplot.getSignificantFigures(number).digitsRight;
    };
}(jQuery);
//# sourceMappingURL=jqplot.sprintf.min.js.map