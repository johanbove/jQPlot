!function($) {
    "use strict";
    $.jqplot.CategoryAxisRenderer = function(options) {
        $.jqplot.LinearAxisRenderer.call(this), this.sortMergedLabels = !1;
    }, $.jqplot.CategoryAxisRenderer.prototype = new $.jqplot.LinearAxisRenderer(), 
    $.jqplot.CategoryAxisRenderer.prototype.constructor = $.jqplot.CategoryAxisRenderer, 
    $.jqplot.CategoryAxisRenderer.prototype.init = function(options) {
        var db, i, j, s, d, seriesLen;
        for (this.groups = 1, this.groupLabels = [], this._groupLabels = [], this._grouped = !1, 
        this._barsPerGroup = null, this.reverse = !1, $.extend(!0, this, {
            tickOptions: {
                formatString: "%d"
            }
        }, options), db = this._dataBounds, i = 0, seriesLen = this._series.length; seriesLen > i; i++) for (s = this._series[i], 
        s.groups && (this.groups = s.groups), d = s.data, j = 0; j < d.length; j++) "xaxis" === this.name || "x2axis" === this.name ? ((null === db.min || d[j][0] < db.min) && (db.min = d[j][0]), 
        (null === db.max || d[j][0] > db.max) && (db.max = d[j][0])) : ((null === db.min || d[j][1] < db.min) && (db.min = d[j][1]), 
        (null === db.max || d[j][1] > db.max) && (db.max = d[j][1]));
        this.groupLabels.length && (this.groups = this.groupLabels.length);
    }, $.jqplot.CategoryAxisRenderer.prototype.createTicks = function() {
        var ticks, userTicks, name, db, dim, min, max, tt, i, j, skip, l, t, s, count, range, labels, numcats, isMerged, idx, labelsLen, track, maxVisibleTicks, val;
        if (ticks = this._ticks, userTicks = this.ticks, name = this.name, db = this._dataBounds, 
        userTicks.length) {
            if (this.groups > 1 && !this._grouped) {
                for (l = userTicks.length, skip = parseInt(l / this.groups, 10), count = 0, i = skip; l > i; i += skip) userTicks.splice(i + count, 0, " "), 
                count++;
                this._grouped = !0;
            }
            for (this.min = .5, this.max = userTicks.length + .5, range = this.max - this.min, 
            this.numberTicks = 2 * userTicks.length + 1, i = 0; i < userTicks.length; i++) tt = this.min + 2 * i * range / (this.numberTicks - 1), 
            t = new this.tickRenderer(this.tickOptions), t.showLabel = !1, t.setTick(tt, this.name), 
            this._ticks.push(t), t = new this.tickRenderer(this.tickOptions), t.label = userTicks[i], 
            t.showMark = !1, t.showGridline = !1, t.setTick(tt + .5, this.name), this._ticks.push(t);
            t = new this.tickRenderer(this.tickOptions), t.showLabel = !1, t.setTick(tt + 1, this.name), 
            this._ticks.push(t);
        } else {
            for (dim = "xaxis" === name || "x2axis" === name ? this._plotDimensions.width : this._plotDimensions.height, 
            null !== this.min && null !== this.max && null !== this.numberTicks && (this.tickInterval = null), 
            null !== this.min && null !== this.max && null !== this.tickInterval && parseInt((this.max - this.min) / this.tickInterval, 10) !== (this.max - this.min) / this.tickInterval && (this.tickInterval = null), 
            labels = [], numcats = 0, min = .5, isMerged = !1, i = 0; i < this._series.length; i++) for (s = this._series[i], 
            j = 0; j < s.data.length; j++) val = "xaxis" === this.name || "x2axis" === this.name ? s.data[j][0] : s.data[j][1], 
            -1 === $.inArray(val, labels) && (isMerged = !0, numcats += 1, labels.push(val));
            for (isMerged && this.sortMergedLabels && ("string" == typeof labels[0] ? labels.sort() : labels.sort(function(a, b) {
                return a - b;
            })), this.ticks = labels, i = 0; i < this._series.length; i++) for (s = this._series[i], 
            j = 0; j < s.data.length; j++) val = "xaxis" === this.name || "x2axis" === this.name ? s.data[j][0] : s.data[j][1], 
            idx = $.inArray(val, labels) + 1, "xaxis" === this.name || "x2axis" === this.name ? s.data[j][0] = idx : s.data[j][1] = idx;
            if (this.groups > 1 && !this._grouped) {
                for (labelsLen = labels.length, skip = parseInt(labelsLen / this.groups, 10), count = 0, 
                i = skip; labelsLen > i; i += skip + 1) labels[i] = " ";
                this._grouped = !0;
            }
            for (max = numcats + .5, null === this.numberTicks && (this.numberTicks = 2 * numcats + 1), 
            range = max - min, this.min = min, this.max = max, track = 0, maxVisibleTicks = parseInt(3 + dim / 10, 10), 
            skip = parseInt(numcats / maxVisibleTicks, 10), null == this.tickInterval && (this.tickInterval = range / (this.numberTicks - 1)), 
            i = 0; i < this.numberTicks; i++) tt = this.min + i * this.tickInterval, t = new this.tickRenderer(this.tickOptions), 
            i / 2 === parseInt(i / 2, 10) ? (t.showLabel = !1, t.showMark = this.tickOptions.showMark) : (skip > 0 && skip > track ? (t.showLabel = !1, 
            track += 1) : (t.showLabel = !0, track = 0), t.label = t.formatter(t.formatString, labels[(i - 1) / 2]), 
            t.showMark = !1, t.showGridline = !1), t.setTick(tt, this.name), this._ticks.push(t);
        }
    }, $.jqplot.CategoryAxisRenderer.prototype.draw = function(ctx, plot) {
        var dim, t, i, elem, tick;
        if (!this.show) return this._elem;
        for (this.renderer.createTicks.call(this), dim = 0, this._elem && this._elem.emptyForce(), 
        this._elem = this._elem || $('<div class="jqplot-axis jqplot-' + this.name + '" style="position:absolute;"></div>'), 
        "xaxis" === this.name || "x2axis" === this.name ? this._elem.width(this._plotDimensions.width) : this._elem.height(this._plotDimensions.height), 
        this.labelOptions.axis = this.name, this._label = new this.labelRenderer(this.labelOptions), 
        this._label.show && (elem = this._label.draw(ctx, plot), elem.appendTo(this._elem)), 
        t = this._ticks, i = 0; i < t.length; i++) tick = t[i], !tick.showLabel || tick.isMinorTick && !this.showMinorTicks || (elem = tick.draw(ctx, plot), 
        elem.appendTo(this._elem));
        for (this._groupLabels = [], i = 0; i < this.groupLabels.length; i++) elem = $('<div style="position:absolute;" class="jqplot-' + this.name + '-groupLabel"></div>'), 
        elem.html(this.groupLabels[i]), this._groupLabels.push(elem), elem.appendTo(this._elem);
        return this._elem;
    }, $.jqplot.CategoryAxisRenderer.prototype.set = function() {
        var dim, dim2, temp, w, h, lshow, t, i, l, tick;
        if (dim = 0, w = 0, h = 0, lshow = null == this._label ? !1 : this._label.show, 
        this.show) {
            for (t = this._ticks, i = 0; i < t.length; i++) tick = t[i], !tick.showLabel || tick.isMinorTick && !this.showMinorTicks || (temp = "xaxis" === this.name || "x2axis" === this.name ? tick._elem.outerHeight(!0) : tick._elem.outerWidth(!0), 
            temp > dim && (dim = temp));
            for (dim2 = 0, i = 0; i < this._groupLabels.length; i++) l = this._groupLabels[i], 
            temp = "xaxis" === this.name || "x2axis" === this.name ? l.outerHeight(!0) : l.outerWidth(!0), 
            temp > dim2 && (dim2 = temp);
            lshow && (w = this._label._elem.outerWidth(!0), h = this._label._elem.outerHeight(!0)), 
            "xaxis" === this.name ? (dim += dim2 + h, this._elem.css({
                height: dim + "px",
                left: "0px",
                bottom: "0px"
            })) : "x2axis" === this.name ? (dim += dim2 + h, this._elem.css({
                height: dim + "px",
                left: "0px",
                top: "0px"
            })) : "yaxis" === this.name ? (dim += dim2 + w, this._elem.css({
                width: dim + "px",
                left: "0px",
                top: "0px"
            }), lshow && this._label.constructor === $.jqplot.AxisLabelRenderer && this._label._elem.css("width", w + "px")) : (dim += dim2 + w, 
            this._elem.css({
                width: dim + "px",
                right: "0px",
                top: "0px"
            }), lshow && this._label.constructor === $.jqplot.AxisLabelRenderer && this._label._elem.css("width", w + "px"));
        }
    }, $.jqplot.CategoryAxisRenderer.prototype.pack = function(pos, offsets) {
        var i, j, p, pixellength, unitlength, t, shim, temp, val, labeledge, w, h, step, mid, count, ticks = this._ticks, max = this.max, min = this.min, offmax = offsets.max, offmin = offsets.min, lshow = null == this._label ? !1 : this._label.show;
        for (p in pos) this._elem.css(p, pos[p]);
        if (this._offsets = offsets, pixellength = offmax - offmin, unitlength = max - min, 
        this.reverse ? (this.u2p = function(u) {
            return offmin + (max - u) * pixellength / unitlength;
        }, this.p2u = function(p) {
            return min + (p - offmin) * unitlength / pixellength;
        }, "xaxis" === this.name || "x2axis" === this.name ? (this.series_u2p = function(u) {
            return (max - u) * pixellength / unitlength;
        }, this.series_p2u = function(p) {
            return p * unitlength / pixellength + max;
        }) : (this.series_u2p = function(u) {
            return (min - u) * pixellength / unitlength;
        }, this.series_p2u = function(p) {
            return p * unitlength / pixellength + min;
        })) : (this.u2p = function(u) {
            return (u - min) * pixellength / unitlength + offmin;
        }, this.p2u = function(p) {
            return (p - offmin) * unitlength / pixellength + min;
        }, "xaxis" === this.name || "x2axis" === this.name ? (this.series_u2p = function(u) {
            return (u - min) * pixellength / unitlength;
        }, this.series_p2u = function(p) {
            return p * unitlength / pixellength + min;
        }) : (this.series_u2p = function(u) {
            return (u - max) * pixellength / unitlength;
        }, this.series_p2u = function(p) {
            return p * unitlength / pixellength + max;
        })), this.show) if ("xaxis" === this.name || "x2axis" === this.name) {
            for (i = 0; i < ticks.length; i++) if (t = ticks[i], t.show && t.showLabel) {
                if (t.constructor === $.jqplot.CanvasAxisTickRenderer && t.angle) switch (temp = "xaxis" == this.name ? 1 : -1, 
                t.labelPosition) {
                  case "auto":
                    shim = temp * t.angle < 0 ? -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2 : -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                    break;

                  case "end":
                    shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                    break;

                  case "start":
                    shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                    break;

                  case "middle":
                    shim = -t.getWidth() / 2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                    break;

                  default:
                    shim = -t.getWidth() / 2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                } else shim = -t.getWidth() / 2;
                val = this.u2p(t.value) + shim + "px", t._elem.css("left", val), t.pack();
            }
            for (labeledge = [ "bottom", 0 ], lshow && (w = this._label._elem.outerWidth(!0), 
            this._label._elem.css("left", offmin + pixellength / 2 - w / 2 + "px"), "xaxis" === this.name ? (this._label._elem.css("bottom", "0px"), 
            labeledge = [ "bottom", this._label._elem.outerHeight(!0) ]) : (this._label._elem.css("top", "0px"), 
            labeledge = [ "top", this._label._elem.outerHeight(!0) ]), this._label.pack()), 
            step = parseInt(this._ticks.length / this.groups, 10) + 1, i = 0; i < this._groupLabels.length; i++) {
                for (mid = 0, count = 0, j = i * step; (i + 1) * step > j; j++) j >= this._ticks.length - 1 || this._ticks[j]._elem && " " !== this._ticks[j].label && (t = this._ticks[j]._elem, 
                p = t.position(), mid += p.left + t.outerWidth(!0) / 2, count++);
                mid /= count, this._groupLabels[i].css({
                    left: mid - this._groupLabels[i].outerWidth(!0) / 2
                }), this._groupLabels[i].css(labeledge[0], labeledge[1]);
            }
        } else {
            for (i = 0; i < ticks.length; i++) if (t = ticks[i], t.show && t.showLabel) {
                if (t.constructor === $.jqplot.CanvasAxisTickRenderer && t.angle) switch (temp = "yaxis" === this.name ? 1 : -1, 
                t.labelPosition) {
                  case "auto":
                  case "end":
                    shim = temp * t.angle < 0 ? -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2 : -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                    break;

                  case "start":
                    shim = t.angle > 0 ? -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2 : -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                    break;

                  case "middle":
                    shim = -t.getHeight() / 2;
                    break;

                  default:
                    shim = -t.getHeight() / 2;
                } else shim = -t.getHeight() / 2;
                val = this.u2p(t.value) + shim + "px", t._elem.css("top", val), t.pack();
            }
            for (labeledge = [ "left", 0 ], lshow && (h = this._label._elem.outerHeight(!0), 
            this._label._elem.css("top", offmax - pixellength / 2 - h / 2 + "px"), "yaxis" === this.name ? (this._label._elem.css("left", "0px"), 
            labeledge = [ "left", this._label._elem.outerWidth(!0) ]) : (this._label._elem.css("right", "0px"), 
            labeledge = [ "right", this._label._elem.outerWidth(!0) ]), this._label.pack()), 
            step = parseInt(this._ticks.length / this.groups, 10) + 1, i = 0; i < this._groupLabels.length; i++) {
                for (mid = 0, count = 0, j = i * step; (i + 1) * step > j; j++) j >= this._ticks.length - 1 || this._ticks[j]._elem && " " !== this._ticks[j].label && (t = this._ticks[j]._elem, 
                p = t.position(), mid += p.top + t.outerHeight() / 2, count++);
                mid /= count, this._groupLabels[i].css({
                    top: mid - this._groupLabels[i].outerHeight() / 2
                }), this._groupLabels[i].css(labeledge[0], labeledge[1]);
            }
        }
    };
}(jQuery);
//# sourceMappingURL=jqplot.categoryAxisRenderer.min.js.map