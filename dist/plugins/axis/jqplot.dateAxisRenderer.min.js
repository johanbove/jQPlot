!function($) {
    "use strict";
    function bestDateInterval(min, max, titarget) {
        var temp, bestTi, bestfmt, i, l, badness = Number.MAX_VALUE;
        for (i = 0, l = NICEINTERVALS.length; l > i; i++) temp = Math.abs(titarget - NICEINTERVALS[i]), 
        badness > temp && (badness = temp, bestTi = NICEINTERVALS[i], bestfmt = NICEFORMATSTRINGS[i]);
        return [ bestTi, bestfmt ];
    }
    Function.prototype.bind || (Function.prototype.bind = function(oThis) {
        if ("function" != typeof this) throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable");
        var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, FNOP = function() {}, fBound = function() {
            return fToBind.apply(this instanceof FNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        return FNOP.prototype = this.prototype, fBound.prototype = new FNOP(), fBound;
    });
    var RendererExistingTicks, RendererOnePointTick, RendererDefaultTicks, RendererBestTicks, SECOND = 1e3, MINUTE = 60 * SECOND, HOUR = 60 * MINUTE, DAY = 24 * HOUR, WEEK = 7 * DAY, MONTH = 30.4368499 * DAY, YEAR = 365.242199 * DAY, NICEFORMATSTRINGS = [ "%M:%S.%#N", "%M:%S.%#N", "%M:%S.%#N", "%M:%S", "%M:%S", "%M:%S", "%M:%S", "%H:%M:%S", "%H:%M:%S", "%H:%M", "%H:%M", "%H:%M", "%H:%M", "%H:%M", "%H:%M", "%a %H:%M", "%a %H:%M", "%b %e %H:%M", "%b %e %H:%M", "%b %e %H:%M", "%b %e %H:%M", "%v", "%v", "%v", "%v", "%v", "%v", "%v" ], NICEINTERVALS = [ .1 * SECOND, .2 * SECOND, .5 * SECOND, SECOND, 2 * SECOND, 5 * SECOND, 10 * SECOND, 15 * SECOND, 30 * SECOND, MINUTE, 2 * MINUTE, 5 * MINUTE, 10 * MINUTE, 15 * MINUTE, 30 * MINUTE, HOUR, 2 * HOUR, 4 * HOUR, 6 * HOUR, 8 * HOUR, 12 * HOUR, DAY, 2 * DAY, 3 * DAY, 4 * DAY, 5 * DAY, WEEK, 2 * WEEK ];
    RendererExistingTicks = function(userTicks) {
        var i, ut, tick, isMinor = !0, now = new Date();
        for (i = 0; i < userTicks.length; i++) ut = userTicks[i], tick = new this.tickRenderer(this.tickOptions), 
        ut.constructor === Array ? (tick.value = new $.jsDate(ut[0]).getTime(), tick.label = ut[1], 
        this.showTicks ? this.showTickMarks || (tick.showMark = !1) : (tick.showLabel = !1, 
        tick.showMark = !1), "%H:%M" === this.tickOptions.formatString && this.tickOptions.labelFullHoursOnly ? (now.setTime(tick.value), 
        isMinor = 0 === now.getMinutes() ? !1 : !0, tick.setTick(tick.value, this.name, isMinor)) : tick.setTick(tick.value, this.name), 
        this._ticks.push(tick)) : (tick.value = new $.jsDate(ut).getTime(), this.showTicks ? this.showTickMarks || (tick.showMark = !1) : (tick.showLabel = !1, 
        tick.showMark = !1), "%H:%M" === this.tickOptions.formatString && this.tickOptions.labelFullHoursOnly && (now.setTime(tick.value), 
        isMinor = 0 === now.getMinutes() ? !1 : !0), tick.setTick(tick.value, this.name, isMinor), 
        this._ticks.push(tick));
        this.numberTicks = userTicks.length, this.min = this._ticks[0].value, this.max = this._ticks[this.numberTicks - 1].value, 
        this.daTickInterval = [ (this.max - this.min) / (this.numberTicks - 1) / 1e3, "seconds" ];
    }, RendererOnePointTick = function(db) {
        var onePointOpts, delta, i, t;
        for (onePointOpts = $.extend(!0, {}, this.tickOptions, {
            name: this.name,
            value: null
        }), delta = 3e5, this.min = db.min - delta, this.max = db.max + delta, this.numberTicks = 3, 
        i = this.min; i <= this.max; i += delta) onePointOpts.value = i, t = new this.tickRenderer(onePointOpts), 
        this._overrideFormatString && "" !== this._autoFormatString && (t.formatString = this._autoFormatString), 
        t.showLabel = !1, t.showMark = !1, this._ticks.push(t);
        this.showTicks && (this._ticks[1].showLabel = !0), this.showTickMarks && (this._ticks[1].showTickMarks = !0);
    }, RendererDefaultTicks = function(daTickInterval, min, max) {
        var dim, range, optNumTicks, rmin, rmax, nc, insetMult, i, tick, tt, adj, name = this.name;
        for (dim = "xaxis" === name || "x2axis" === name ? this._plotDimensions.width : this._plotDimensions.height, 
        null !== this.min && null !== this.max && null !== this.numberTicks && (this.tickInterval = null), 
        null !== this.tickInterval && null !== daTickInterval && (this.daTickInterval = daTickInterval), 
        min === max && (adj = 432e5, min -= adj, max += adj), range = max - min, optNumTicks = 2 + parseInt(Math.max(0, dim - 100) / 100, 10), 
        rmin = null !== this.min ? new $.jsDate(this.min).getTime() : min - range / 2 * (this.padMin - 1), 
        rmax = null !== this.max ? new $.jsDate(this.max).getTime() : max + range / 2 * (this.padMax - 1), 
        this.min = rmin, this.max = rmax, range = this.max - this.min, null === this.numberTicks && (null !== this.daTickInterval ? (nc = new $.jsDate(this.max).diff(this.min, this.daTickInterval[1], !0), 
        this.numberTicks = Math.ceil(nc / this.daTickInterval[0]) + 1, this.max = new $.jsDate(this.min).add((this.numberTicks - 1) * this.daTickInterval[0], this.daTickInterval[1]).getTime()) : dim > 200 ? this.numberTicks = parseInt(3 + (dim - 200) / 100, 10) : this.numberTicks = 2), 
        insetMult = range / (this.numberTicks - 1) / 1e3, null === this.daTickInterval && (this.daTickInterval = [ insetMult, "seconds" ]), 
        i = 0; i < this.numberTicks; i++) min = new $.jsDate(this.min), tt = min.add(i * this.daTickInterval[0], this.daTickInterval[1]).getTime(), 
        tick = new this.tickRenderer(this.tickOptions), this.showTicks ? this.showTickMarks || (tick.showMark = !1) : (tick.showLabel = !1, 
        tick.showMark = !1), tick.setTick(tt, this.name), this._ticks.push(tick);
        return insetMult;
    }, RendererBestTicks = function(threshold, min, max, daTickInterval) {
        var insetMult, nttarget, titarget, tdim, spacingFactor, ret, tempti, i, tick, intv, mstart, tempmend, mend, nmonths, nyears, opts = $.extend(!0, {}, this.tickOptions, {
            name: this.name,
            value: null
        }), dim = "x" === this.name.charAt(0) ? this._plotDimensions.width : this._plotDimensions.height;
        if (this.tickInterval || this.numberTicks ? this.tickInterval ? titarget = new $.jsDate(0).add(daTickInterval[0], daTickInterval[1]).getTime() : this.numberTicks && (nttarget = this.numberTicks, 
        titarget = (max - min) / (nttarget - 1)) : (tdim = Math.max(dim, threshold + 1), 
        spacingFactor = 115, this.tickRenderer === $.jqplot.CanvasAxisTickRenderer && this.tickOptions.angle && (spacingFactor = 115 - 40 * Math.abs(Math.sin(this.tickOptions.angle / 180 * Math.PI))), 
        nttarget = Math.ceil((tdim - threshold) / spacingFactor + 1), titarget = (max - min) / (nttarget - 1)), 
        19 * DAY >= titarget) {
            for (ret = bestDateInterval(min, max, titarget), tempti = ret[0], this._autoFormatString = ret[1], 
            min = new $.jsDate(min), min = Math.floor((min.getTime() - min.getUtcOffset()) / tempti) * tempti + min.getUtcOffset(), 
            nttarget = Math.ceil((max - min) / tempti) + 1, this.min = min, this.max = min + (nttarget - 1) * tempti, 
            this.max < max && (this.max += tempti, nttarget += 1), this.tickInterval = tempti, 
            this.numberTicks = nttarget, i = 0; nttarget > i; i++) opts.value = this.min + i * tempti, 
            tick = new this.tickRenderer(opts), this._overrideFormatString && "" !== this._autoFormatString && (tick.formatString = this._autoFormatString), 
            this.showTicks ? this.showTickMarks || (tick.showMark = !1) : (tick.showLabel = !1, 
            tick.showMark = !1), this._ticks.push(tick);
            insetMult = this.tickInterval;
        } else if (9 * MONTH >= titarget) {
            for (this._autoFormatString = "%v", intv = Math.round(titarget / MONTH), 1 > intv ? intv = 1 : intv > 6 && (intv = 6), 
            mstart = new $.jsDate(min).setDate(1).setHours(0, 0, 0, 0), tempmend = new $.jsDate(max), 
            mend = new $.jsDate(max).setDate(1).setHours(0, 0, 0, 0), tempmend.getTime() !== mend.getTime() && (mend = mend.add(1, "month")), 
            nmonths = mend.diff(mstart, "month"), nttarget = Math.ceil(nmonths / intv) + 1, 
            this.min = mstart.getTime(), this.max = mstart.clone().add((nttarget - 1) * intv, "month").getTime(), 
            this.numberTicks = nttarget, i = 0; nttarget > i; i++) 0 === i ? opts.value = mstart.getTime() : opts.value = mstart.add(intv, "month").getTime(), 
            tick = new this.tickRenderer(opts), this._overrideFormatString && "" !== this._autoFormatString && (tick.formatString = this._autoFormatString), 
            this.showTicks ? this.showTickMarks || (tick.showMark = !1) : (tick.showLabel = !1, 
            tick.showMark = !1), this._ticks.push(tick);
            insetMult = intv * MONTH;
        } else {
            for (this._autoFormatString = "%v", intv = Math.round(titarget / YEAR), 1 > intv && (intv = 1), 
            mstart = new $.jsDate(min).setMonth(0, 1).setHours(0, 0, 0, 0), mend = new $.jsDate(max).add(1, "year").setMonth(0, 1).setHours(0, 0, 0, 0), 
            nyears = mend.diff(mstart, "year"), nttarget = Math.ceil(nyears / intv) + 1, this.min = mstart.getTime(), 
            this.max = mstart.clone().add((nttarget - 1) * intv, "year").getTime(), this.numberTicks = nttarget, 
            i = 0; nttarget > i; i++) 0 === i ? opts.value = mstart.getTime() : opts.value = mstart.add(intv, "year").getTime(), 
            tick = new this.tickRenderer(opts), this._overrideFormatString && "" !== this._autoFormatString && (tick.formatString = this._autoFormatString), 
            this.showTicks ? this.showTickMarks || (tick.showMark = !1) : (tick.showLabel = !1, 
            tick.showMark = !1), this._ticks.push(tick);
            insetMult = intv * YEAR;
        }
        return insetMult;
    }, $.jqplot.DateAxisRenderer = function() {
        $.jqplot.LinearAxisRenderer.call(this), this.date = new $.jsDate();
    }, $.jqplot.DateAxisRenderer.prototype = new $.jqplot.LinearAxisRenderer(), $.jqplot.DateAxisRenderer.prototype.constructor = $.jqplot.DateAxisRenderer, 
    $.jqplot.DateTickFormatter = function(typeFormatter) {
        this.typeFormatter = typeFormatter;
    }, $.jqplot.DateTickFormatter.prototype.format = function(format, val) {
        return format || (format = "%Y/%m/%d"), $.jsDate.strftime(val, format, this.typeFormatter);
    }, $.jqplot.DateAxisRenderer.prototype.init = function(options) {
        var stats, sum, s, d, pd, sd, intv, i, j, l, bd, tempf, tempn, key, db = this._dataBounds, frequencySort = function(a, b) {
            return b.frequency - a.frequency;
        };
        for (this.tickOptions.typeFormatter = this.tickOptions.typeFormatter || "perl", 
        this.tickOptions.formatter = new $.jqplot.DateTickFormatter(this.tickOptions.typeFormatter).format, 
        this.tickOptions.labelFullHoursOnly = "undefined" != typeof this.tickOptions.labelFullHoursOnly ? this.tickOptions.labelFullHoursOnly : !1, 
        this.tickInset = 0, this.drawBaseline = "undefined" != typeof this.drawBaseline ? this.drawBaseline : !0, 
        this.baselineWidth = null, this.baselineColor = null, this.daTickInterval = null, 
        this._daTickInterval = null, $.extend(!0, this, options), i = 0; i < this._series.length; i++) {
            for (stats = {
                intervals: [],
                frequencies: {},
                sortedIntervals: [],
                min: null,
                max: null,
                mean: null
            }, sum = 0, s = this._series[i], d = s.data, pd = s._plotData, sd = s._stackData, 
            intv = 0, j = 0; j < d.length; j++) "xaxis" === this.name || "x2axis" === this.name ? (d[j][0] = new $.jsDate(d[j][0]).getTime(), 
            pd[j][0] = new $.jsDate(d[j][0]).getTime(), sd[j][0] = new $.jsDate(d[j][0]).getTime(), 
            (null !== d[j][0] && d[j][0] < db.min || null === db.min) && (db.min = d[j][0]), 
            (null !== d[j][0] && d[j][0] > db.max || null === db.max) && (db.max = d[j][0]), 
            j > 0 && (intv = Math.abs(d[j][0] - d[j - 1][0]), stats.intervals.push(intv), stats.frequencies.hasOwnProperty(intv) ? stats.frequencies[intv] += 1 : stats.frequencies[intv] = 1), 
            sum += intv) : (d[j][1] = new $.jsDate(d[j][1]).getTime(), pd[j][1] = new $.jsDate(d[j][1]).getTime(), 
            sd[j][1] = new $.jsDate(d[j][1]).getTime(), (null !== d[j][1] && d[j][1] < db.min || null === db.min) && (db.min = d[j][1]), 
            (null !== d[j][1] && d[j][1] > db.max || null === db.max) && (db.max = d[j][1]), 
            j > 0 && (intv = Math.abs(d[j][1] - d[j - 1][1]), stats.intervals.push(intv), stats.frequencies.hasOwnProperty(intv) ? stats.frequencies[intv] += 1 : stats.frequencies[intv] = 1)), 
            sum += intv;
            if (s.renderer.bands) {
                if (s.renderer.bands.hiData.length) for (bd = s.renderer.bands.hiData, j = 0, l = bd.length; l > j; j++) "xaxis" === this.name || "x2axis" === this.name ? (bd[j][0] = new $.jsDate(bd[j][0]).getTime(), 
                (null !== bd[j][0] && bd[j][0] > db.max || null === db.max) && (db.max = bd[j][0])) : (bd[j][1] = new $.jsDate(bd[j][1]).getTime(), 
                (null !== bd[j][1] && bd[j][1] > db.max || null === db.max) && (db.max = bd[j][1]));
                if (s.renderer.bands.lowData.length) for (bd = s.renderer.bands.lowData, j = 0, 
                l = bd.length; l > j; j++) "xaxis" === this.name || "x2axis" === this.name ? (bd[j][0] = new $.jsDate(bd[j][0]).getTime(), 
                (null !== bd[j][0] && bd[j][0] < db.min || null === db.min) && (db.min = bd[j][0])) : (bd[j][1] = new $.jsDate(bd[j][1]).getTime(), 
                (null !== bd[j][1] && bd[j][1] < db.min || null === db.min) && (db.min = bd[j][1]));
            }
            tempf = 0, tempn = 0;
            for (key in stats.frequencies) stats.frequencies.hasOwnProperty(key) && stats.sortedIntervals.push({
                interval: key,
                frequency: stats.frequencies[key]
            });
            stats.sortedIntervals.sort(frequencySort), stats.min = $.jqplot.arrayMin(stats.intervals), 
            stats.max = $.jqplot.arrayMax(stats.intervals), stats.mean = sum / d.length, this._intervalStats.push(stats), 
            stats = sum = s = d = pd = sd = null;
        }
        db = null;
    }, $.jqplot.DateAxisRenderer.prototype.reset = function() {
        this.min = this._options.min, this.max = this._options.max, this.tickInterval = this._options.tickInterval, 
        this.numberTicks = this._options.numberTicks, this._autoFormatString = "", this._overrideFormatString && this.tickOptions && this.tickOptions.formatString && (this.tickOptions.formatString = ""), 
        this.daTickInterval = this._daTickInterval;
    }, $.jqplot.DateAxisRenderer.prototype.createTicks = function(plot) {
        var ticks, userTicks, name, db, iv, dim, min, max, threshold, insetMult, daTickInterval, parts, tickInterval, cursor, range, renderTicks = null;
        ticks = this._ticks, userTicks = this.ticks, name = this.name, db = this._dataBounds, 
        iv = this._intervalStats, dim = "x" === this.name.charAt(0) ? this._plotDimensions.width : this._plotDimensions.height, 
        threshold = 30, insetMult = 1, daTickInterval = null, null !== this.tickInterval && (Number(this.tickInterval) ? daTickInterval = [ Number(this.tickInterval), "seconds" ] : "string" == typeof this.tickInterval && (parts = this.tickInterval.split(" "), 
        1 === parts.length ? daTickInterval = [ 1, parts[0] ] : 2 === parts.length && (daTickInterval = [ parts[0], parts[1] ]))), 
        tickInterval = this.tickInterval, min = new $.jsDate(null !== this.min ? this.min : db.min).getTime(), 
        max = new $.jsDate(null !== this.max ? this.max : db.max).getTime(), cursor = plot.plugins.cursor, 
        cursor && cursor._zoom && cursor._zoom.zooming && (this.min = null, this.max = null), 
        range = max - min, null !== this.tickOptions && this.tickOptions.formatString || (this._overrideFormatString = !0), 
        userTicks.length ? (renderTicks = RendererExistingTicks.bind(this))(userTicks) : null === this.min && null === this.max && db.min === db.max ? (renderTicks = RendererOnePointTick.bind(this))(db) : null === this.min && null === this.max ? (renderTicks = RendererBestTicks.bind(this), 
        insetMult = renderTicks(threshold, min, max, daTickInterval)) : (renderTicks = RendererDefaultTicks.bind(this), 
        insetMult = renderTicks(daTickInterval, min, max)), this.tickInset && (this.min = this.min - this.tickInset * insetMult, 
        this.max = this.max + this.tickInset * insetMult), null === this._daTickInterval && (this._daTickInterval = this.daTickInterval), 
        ticks = null;
    };
}(jQuery);
//# sourceMappingURL=jqplot.dateAxisRenderer.min.js.map