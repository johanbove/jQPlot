!function($) {
    $.jqplot.LogAxisRenderer = function() {
        $.jqplot.LinearAxisRenderer.call(this), this.axisDefaults = {
            base: 10,
            tickDistribution: "power"
        };
    }, $.jqplot.LogAxisRenderer.prototype = new $.jqplot.LinearAxisRenderer(), $.jqplot.LogAxisRenderer.prototype.constructor = $.jqplot.LogAxisRenderer, 
    $.jqplot.LogAxisRenderer.prototype.init = function(options) {
        this.drawBaseline = !0, this.minorTicks = "auto", this._scalefact = 1, $.extend(!0, this, options), 
        this._autoFormatString = "%d", this._overrideFormatString = !1;
        for (var d in this.renderer.axisDefaults) null == this[d] && (this[d] = this.renderer.axisDefaults[d]);
        this.resetDataBounds();
    }, $.jqplot.LogAxisRenderer.prototype.createTicks = function(plot) {
        var interval, min, max, tt, i, userTicks = (this._ticks, this.ticks), db = (this.name, 
        this._dataBounds), dim = "x" === this.name.charAt(0) ? this._plotDimensions.width : this._plotDimensions.height, threshold = 30;
        if (this._scalefact = (Math.max(dim, threshold + 1) - threshold) / 300, userTicks.length) {
            for (i = 0; i < userTicks.length; i++) {
                var ut = userTicks[i], t = new this.tickRenderer(this.tickOptions);
                ut.constructor == Array ? (t.value = ut[0], t.label = ut[1], this.showTicks ? this.showTickMarks || (t.showMark = !1) : (t.showLabel = !1, 
                t.showMark = !1), t.setTick(ut[0], this.name), this._ticks.push(t)) : $.isPlainObject(ut) ? ($.extend(!0, t, ut), 
                t.axis = this.name, this._ticks.push(t)) : (t.value = ut, this.showTicks ? this.showTickMarks || (t.showMark = !1) : (t.showLabel = !1, 
                t.showMark = !1), t.setTick(ut, this.name), this._ticks.push(t));
            }
            this.numberTicks = userTicks.length, this.min = this._ticks[0].value, this.max = this._ticks[this.numberTicks - 1].value;
        } else if (null == this.min && null == this.max) {
            if (min = db.min * (2 - this.padMin), max = db.max * this.padMax, min == max) {
                var adj = .05;
                min *= 1 - adj, max *= 1 + adj;
            }
            if (null != this.min && this.min <= 0) throw new Error("Log axis minimum must be greater than 0");
            if (null != this.max && this.max <= 0) throw new Error("Log axis maximum must be greater than 0");
            var rmin, rmax;
            rmin = Math.pow(this.base, Math.floor(Math.log(min) / Math.log(this.base))), rmax = Math.pow(this.base, Math.ceil(Math.log(max) / Math.log(this.base))), 
            0 === rmin && (rmin = 1);
            var order = Math.round(Math.log(rmin) / Math.LN10);
            null != this.tickOptions && this.tickOptions.formatString || (this._overrideFormatString = !0), 
            this.min = rmin, this.max = rmax;
            var numberTicks, minorTicks = (this.max - this.min, "auto" === this.minorTicks ? 0 : this.minorTicks);
            if (null == this.numberTicks) if (dim > 140) {
                if (numberTicks = Math.round(Math.log(this.max / this.min) / Math.log(this.base) + 1), 
                2 > numberTicks && (numberTicks = 2), 0 === minorTicks) {
                    var temp = dim / (numberTicks - 1);
                    minorTicks = 100 > temp ? 0 : 190 > temp ? 1 : 250 > temp ? 3 : 600 > temp ? 4 : 9;
                }
            } else numberTicks = 2, 0 === minorTicks && (minorTicks = 1), minorTicks = 0; else numberTicks = this.numberTicks;
            if (order >= 0 && 3 !== minorTicks) this._autoFormatString = "%d"; else if (0 >= order && 3 === minorTicks) {
                var temp = -(order - 1);
                this._autoFormatString = "%." + Math.abs(order - 1) + "f";
            } else if (0 > order) {
                var temp = -order;
                this._autoFormatString = "%." + Math.abs(order) + "f";
            } else this._autoFormatString = "%d";
            for (var t, val, tt1, spread, interval, i = 0; numberTicks > i; i++) if (tt = Math.pow(this.base, i - numberTicks + 1) * this.max, 
            t = new this.tickRenderer(this.tickOptions), this._overrideFormatString && (t.formatString = this._autoFormatString), 
            this.showTicks ? this.showTickMarks || (t.showMark = !1) : (t.showLabel = !1, t.showMark = !1), 
            t.setTick(tt, this.name), this._ticks.push(t), minorTicks && numberTicks - 1 > i) {
                tt1 = Math.pow(this.base, i - numberTicks + 2) * this.max, spread = tt1 - tt, interval = tt1 / (minorTicks + 1);
                for (var j = minorTicks - 1; j >= 0; j--) val = tt1 - interval * (j + 1), t = new this.tickRenderer(this.tickOptions), 
                this._overrideFormatString && "" != this._autoFormatString && (t.formatString = this._autoFormatString), 
                this.showTicks ? this.showTickMarks || (t.showMark = !1) : (t.showLabel = !1, t.showMark = !1), 
                t.setTick(val, this.name), this._ticks.push(t);
            }
        } else if (null != this.min && null != this.max) {
            var nt, ti, opts = $.extend(!0, {}, this.tickOptions, {
                name: this.name,
                value: null
            });
            if (null == this.numberTicks && null == this.tickInterval) {
                var tdim = Math.max(dim, threshold + 1), nttarget = Math.ceil((tdim - threshold) / 35 + 1), ret = $.jqplot.LinearTickGenerator.bestConstrainedInterval(this.min, this.max, nttarget);
                this._autoFormatString = ret[3], nt = ret[2], ti = ret[4];
                for (var i = 0; nt > i; i++) opts.value = this.min + i * ti, t = new this.tickRenderer(opts), 
                this._overrideFormatString && "" != this._autoFormatString && (t.formatString = this._autoFormatString), 
                this.showTicks ? this.showTickMarks || (t.showMark = !1) : (t.showLabel = !1, t.showMark = !1), 
                this._ticks.push(t);
            } else if (null != this.numberTicks && null != this.tickInterval) {
                nt = this.numberTicks;
                for (var i = 0; nt > i; i++) opts.value = this.min + i * this.tickInterval, t = new this.tickRenderer(opts), 
                this._overrideFormatString && "" != this._autoFormatString && (t.formatString = this._autoFormatString), 
                this.showTicks ? this.showTickMarks || (t.showMark = !1) : (t.showLabel = !1, t.showMark = !1), 
                this._ticks.push(t);
            }
        }
    }, $.jqplot.LogAxisRenderer.prototype.pack = function(pos, offsets) {
        var lb = parseInt(this.base, 10), ticks = this._ticks, trans = function(v) {
            return Math.log(v) / Math.log(lb);
        }, invtrans = function(v) {
            return Math.pow(Math.E, Math.log(lb) * v);
        }, max = trans(this.max), min = trans(this.min), offmax = offsets.max, offmin = offsets.min, lshow = null == this._label ? !1 : this._label.show;
        for (var p in pos) this._elem.css(p, pos[p]);
        this._offsets = offsets;
        var pixellength = offmax - offmin, unitlength = max - min;
        if (this.p2u = function(p) {
            return invtrans((p - offmin) * unitlength / pixellength + min);
        }, this.u2p = function(u) {
            return (trans(u) - min) * pixellength / unitlength + offmin;
        }, "xaxis" == this.name || "x2axis" == this.name ? (this.series_u2p = function(u) {
            return (trans(u) - min) * pixellength / unitlength;
        }, this.series_p2u = function(p) {
            return invtrans(p * unitlength / pixellength + min);
        }) : (this.series_u2p = function(u) {
            return (trans(u) - max) * pixellength / unitlength;
        }, this.series_p2u = function(p) {
            return invtrans(p * unitlength / pixellength + max);
        }), this.show) if ("xaxis" == this.name || "x2axis" == this.name) {
            for (var i = 0; i < ticks.length; i++) {
                var t = ticks[i];
                if (t.show && t.showLabel) {
                    var shim;
                    if (t.constructor == $.jqplot.CanvasAxisTickRenderer && t.angle) switch (t.labelPosition) {
                      case "auto":
                        shim = t.angle < 0 ? -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2 : -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                        break;

                      case "end":
                        shim = -t.getWidth() + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                        break;

                      case "start":
                        shim = -t._textRenderer.height * Math.sin(t._textRenderer.angle) / 2;
                        break;

                      case "middle":
                        shim = -t.getWidth() / 2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                        break;

                      default:
                        shim = -t.getWidth() / 2 + t._textRenderer.height * Math.sin(-t._textRenderer.angle) / 2;
                    } else shim = -t.getWidth() / 2;
                    var val = this.u2p(t.value) + shim + "px";
                    t._elem.css("left", val), t.pack();
                }
            }
            if (lshow) {
                var w = this._label._elem.outerWidth(!0);
                this._label._elem.css("left", offmin + pixellength / 2 - w / 2 + "px"), "xaxis" == this.name ? this._label._elem.css("bottom", "0px") : this._label._elem.css("top", "0px"), 
                this._label.pack();
            }
        } else {
            for (var i = 0; i < ticks.length; i++) {
                var t = ticks[i];
                if (t.show && t.showLabel) {
                    var shim;
                    if (t.constructor == $.jqplot.CanvasAxisTickRenderer && t.angle) switch (t.labelPosition) {
                      case "auto":
                      case "end":
                        shim = t.angle < 0 ? -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2 : -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                        break;

                      case "start":
                        shim = t.angle > 0 ? -t._textRenderer.height * Math.cos(-t._textRenderer.angle) / 2 : -t.getHeight() + t._textRenderer.height * Math.cos(t._textRenderer.angle) / 2;
                        break;

                      case "middle":
                        shim = -t.getHeight() / 2;
                        break;

                      default:
                        shim = -t.getHeight() / 2;
                    } else shim = -t.getHeight() / 2;
                    var val = this.u2p(t.value) + shim + "px";
                    t._elem.css("top", val), t.pack();
                }
            }
            if (lshow) {
                var h = this._label._elem.outerHeight(!0);
                this._label._elem.css("top", offmax - pixellength / 2 - h / 2 + "px"), "yaxis" == this.name ? this._label._elem.css("left", "0px") : this._label._elem.css("right", "0px"), 
                this._label.pack();
            }
        }
    };
}(jQuery);
//# sourceMappingURL=jqplot.logAxisRenderer.min.js.map