!function($) {
    function barPreInit(target, data, seriesDefaults, options) {
        if ("horizontal" == this.rendererOptions.barDirection && (this._stackAxis = "x", 
        this._primaryAxis = "_yaxis"), 1 == this.rendererOptions.waterfall) {
            this._data = $.extend(!0, [], this.data);
            for (var sum = 0, pos = this.rendererOptions.barDirection && "vertical" !== this.rendererOptions.barDirection && this.transposedData !== !1 ? 0 : 1, i = 0; i < this.data.length; i++) sum += this.data[i][pos], 
            i > 0 && (this.data[i][pos] += this.data[i - 1][pos]);
            this.data[this.data.length] = 1 == pos ? [ this.data.length + 1, sum ] : [ sum, this.data.length + 1 ], 
            this._data[this._data.length] = 1 == pos ? [ this._data.length + 1, sum ] : [ sum, this._data.length + 1 ];
        }
        if (this.rendererOptions.groups > 1) {
            this.breakOnNull = !0;
            for (var l = this.data.length, skip = parseInt(l / this.rendererOptions.groups, 10), count = 0, i = skip; l > i; i += skip) this.data.splice(i + count, 0, [ null, null ]), 
            this._plotData.splice(i + count, 0, [ null, null ]), this._stackData.splice(i + count, 0, [ null, null ]), 
            count++;
            for (i = 0; i < this.data.length; i++) "_xaxis" == this._primaryAxis ? (this.data[i][0] = i + 1, 
            this._plotData[i][0] = i + 1, this._stackData[i][0] = i + 1) : (this.data[i][1] = i + 1, 
            this._plotData[i][1] = i + 1, this._stackData[i][1] = i + 1);
        }
    }
    function getStart(sidx, didx, comp, plot, axis) {
        var start, prevVal, seriesIndex = sidx, prevSeriesIndex = sidx - 1, aidx = "x" === axis ? 0 : 1;
        return seriesIndex > 0 ? (prevVal = plot.series[prevSeriesIndex]._plotData[didx][aidx], 
        start = 0 > comp * prevVal ? getStart(prevSeriesIndex, didx, comp, plot, axis) : plot.series[prevSeriesIndex].gridData[didx][aidx]) : start = 0 === aidx ? plot.series[seriesIndex]._xaxis.series_u2p(0) : plot.series[seriesIndex]._yaxis.series_u2p(0), 
        start;
    }
    function postInit(target, data, options) {
        for (var i = 0; i < this.series.length; i++) this.series[i].renderer.constructor == $.jqplot.BarRenderer && this.series[i].highlightMouseOver && (this.series[i].highlightMouseDown = !1);
    }
    function postPlotDraw() {
        this.plugins.barRenderer && this.plugins.barRenderer.highlightCanvas && (this.plugins.barRenderer.highlightCanvas.resetCanvas(), 
        this.plugins.barRenderer.highlightCanvas = null), this.plugins.barRenderer = {
            highlightedSeriesIndex: null
        }, this.plugins.barRenderer.highlightCanvas = new $.jqplot.GenericCanvas(), this.eventCanvas._elem.before(this.plugins.barRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-barRenderer-highlight-canvas", this._plotDimensions, this)), 
        this.plugins.barRenderer.highlightCanvas.setContext(), this.eventCanvas._elem.bind("mouseleave", {
            plot: this
        }, function(ev) {
            unhighlight(ev.data.plot);
        });
    }
    function highlight(plot, sidx, pidx, points) {
        var s = plot.series[sidx], canvas = plot.plugins.barRenderer.highlightCanvas;
        canvas._ctx.clearRect(0, 0, canvas._ctx.canvas.width, canvas._ctx.canvas.height), 
        s._highlightedPoint = pidx, plot.plugins.barRenderer.highlightedSeriesIndex = sidx;
        var opts = {
            fillStyle: s.highlightColors[pidx]
        };
        s.renderer.shapeRenderer.draw(canvas._ctx, points, opts), canvas = null;
    }
    function unhighlight(plot) {
        var canvas = plot.plugins.barRenderer.highlightCanvas;
        canvas._ctx.clearRect(0, 0, canvas._ctx.canvas.width, canvas._ctx.canvas.height);
        for (var i = 0; i < plot.series.length; i++) plot.series[i]._highlightedPoint = null;
        plot.plugins.barRenderer.highlightedSeriesIndex = null, plot.target.trigger("jqplotDataUnhighlight"), 
        canvas = null;
    }
    function handleMove(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [ neighbor.seriesIndex, neighbor.pointIndex, neighbor.data ], evt1 = jQuery.Event("jqplotDataMouseOver");
            if (evt1.pageX = ev.pageX, evt1.pageY = ev.pageY, plot.target.trigger(evt1, ins), 
            plot.series[ins[0]].show && plot.series[ins[0]].highlightMouseOver && (ins[0] != plot.plugins.barRenderer.highlightedSeriesIndex || ins[1] != plot.series[ins[0]]._highlightedPoint)) {
                var evt = jQuery.Event("jqplotDataHighlight");
                evt.which = ev.which, evt.pageX = ev.pageX, evt.pageY = ev.pageY, plot.target.trigger(evt, ins), 
                highlight(plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);
            }
        } else null == neighbor && unhighlight(plot);
    }
    function handleMouseDown(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [ neighbor.seriesIndex, neighbor.pointIndex, neighbor.data ];
            if (plot.series[ins[0]].highlightMouseDown && (ins[0] != plot.plugins.barRenderer.highlightedSeriesIndex || ins[1] != plot.series[ins[0]]._highlightedPoint)) {
                var evt = jQuery.Event("jqplotDataHighlight");
                evt.which = ev.which, evt.pageX = ev.pageX, evt.pageY = ev.pageY, plot.target.trigger(evt, ins), 
                highlight(plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);
            }
        } else null == neighbor && unhighlight(plot);
    }
    function handleMouseUp(ev, gridpos, datapos, neighbor, plot) {
        var idx = plot.plugins.barRenderer.highlightedSeriesIndex;
        null != idx && plot.series[idx].highlightMouseDown && unhighlight(plot);
    }
    function handleClick(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [ neighbor.seriesIndex, neighbor.pointIndex, neighbor.data ], evt = jQuery.Event("jqplotDataClick");
            evt.which = ev.which, evt.pageX = ev.pageX, evt.pageY = ev.pageY, plot.target.trigger(evt, ins);
        }
    }
    function handleRightClick(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [ neighbor.seriesIndex, neighbor.pointIndex, neighbor.data ], idx = plot.plugins.barRenderer.highlightedSeriesIndex;
            null != idx && plot.series[idx].highlightMouseDown && unhighlight(plot);
            var evt = jQuery.Event("jqplotDataRightClick");
            evt.which = ev.which, evt.pageX = ev.pageX, evt.pageY = ev.pageY, plot.target.trigger(evt, ins);
        }
    }
    $.jqplot.BarRenderer = function() {
        $.jqplot.LineRenderer.call(this);
    }, $.jqplot.BarRenderer.prototype = new $.jqplot.LineRenderer(), $.jqplot.BarRenderer.prototype.constructor = $.jqplot.BarRenderer, 
    $.jqplot.BarRenderer.prototype.init = function(options, plot) {
        this.barPadding = 8, this.barMargin = 10, this.barDirection = "vertical", this.barWidth = null, 
        this.shadowOffset = 2, this.shadowDepth = 5, this.shadowAlpha = .08, this.waterfall = !1, 
        this.groups = 1, this.varyBarColor = !1, this.highlightMouseOver = !0, this.highlightMouseDown = !1, 
        this.highlightColors = [], this.transposedData = !0, this.renderer.animation = {
            show: !1,
            direction: "down",
            speed: 3e3,
            _supported: !0
        }, this._type = "bar", options.highlightMouseDown && null == options.highlightMouseOver && (options.highlightMouseOver = !1), 
        $.extend(!0, this, options), $.extend(!0, this.renderer, options), this.fill = !0, 
        "horizontal" === this.barDirection && this.rendererOptions.animation && null == this.rendererOptions.animation.direction && (this.renderer.animation.direction = "left"), 
        this.waterfall && (this.fillToZero = !1, this.disableStack = !0), "vertical" == this.barDirection ? (this._primaryAxis = "_xaxis", 
        this._stackAxis = "y", this.fillAxis = "y") : (this._primaryAxis = "_yaxis", this._stackAxis = "x", 
        this.fillAxis = "x"), this._highlightedPoint = null, this._plotSeriesInfo = null, 
        this._dataColors = [], this._barPoints = [];
        var opts = {
            lineJoin: "miter",
            lineCap: "round",
            fill: !0,
            isarc: !1,
            strokeStyle: this.color,
            fillStyle: this.color,
            closePath: this.fill,
            fillGradient: this.fillGradient,
            fillGradientColor: this.fillGradientColor,
            fillGradientDelay: this.fillGradientDelay
        };
        this.renderer.shapeRenderer.init(opts);
        var sopts = {
            lineJoin: "miter",
            lineCap: "round",
            fill: !0,
            isarc: !1,
            angle: this.shadowAngle,
            offset: this.shadowOffset,
            alpha: this.shadowAlpha,
            depth: this.shadowDepth,
            closePath: this.fill
        };
        this.renderer.shadowRenderer.init(sopts), plot.postInitHooks.addOnce(postInit), 
        plot.postDrawHooks.addOnce(postPlotDraw), plot.eventListenerHooks.addOnce("jqplotMouseMove", handleMove), 
        plot.eventListenerHooks.addOnce("jqplotMouseDown", handleMouseDown), plot.eventListenerHooks.addOnce("jqplotMouseUp", handleMouseUp), 
        plot.eventListenerHooks.addOnce("jqplotClick", handleClick), plot.eventListenerHooks.addOnce("jqplotRightClick", handleRightClick);
    }, $.jqplot.preSeriesInitHooks.push(barPreInit), $.jqplot.BarRenderer.prototype.calcSeriesNumbers = function() {
        for (var series, pos, nvals = 0, nseries = 0, paxis = this[this._primaryAxis], i = 0; i < paxis._series.length; i++) series = paxis._series[i], 
        series === this && (pos = nseries), series.renderer.constructor == $.jqplot.BarRenderer && (nvals += series.data.length, 
        nseries += 1);
        return [ nvals, nseries, pos ];
    }, $.jqplot.BarRenderer.prototype.setBarWidth = function() {
        var nvals = 0, nseries = 0, paxis = this[this._primaryAxis], temp = this._plotSeriesInfo = this.renderer.calcSeriesNumbers.call(this);
        nvals = temp[0], nseries = temp[1];
        var nticks = paxis.numberTicks, nbins = (nticks - 1) / 2;
        return "xaxis" == paxis.name || "x2axis" == paxis.name ? this._stack ? this.barWidth = (paxis._offsets.max - paxis._offsets.min) / nvals * nseries - this.barMargin : this.barWidth = ((paxis._offsets.max - paxis._offsets.min) / nbins - this.barPadding * (nseries - 1) - 2 * this.barMargin) / nseries : this._stack ? this.barWidth = (paxis._offsets.min - paxis._offsets.max) / nvals * nseries - this.barMargin : this.barWidth = ((paxis._offsets.min - paxis._offsets.max) / nbins - this.barPadding * (nseries - 1) - 2 * this.barMargin) / nseries, 
        [ nvals, nseries ];
    }, $.jqplot.BarRenderer.prototype.draw = function(ctx, gridData, options, plot) {
        var i, opts = $.extend({}, options), shadow = void 0 != opts.shadow ? opts.shadow : this.shadow, showLine = void 0 != opts.showLine ? opts.showLine : this.showLine;
        void 0 != opts.fill ? opts.fill : this.fill, this.xaxis, this.yaxis, this._xaxis.series_u2p, 
        this._yaxis.series_u2p;
        this._dataColors = [], this._barPoints = [], null == this.barWidth && this.renderer.setBarWidth.call(this);
        var temp = this._plotSeriesInfo = this.renderer.calcSeriesNumbers.call(this), nseries = (temp[0], 
        temp[1]), pos = temp[2], points = [];
        if (this._stack ? this._barNudge = 0 : this._barNudge = (-Math.abs(nseries / 2 - .5) + pos) * (this.barWidth + this.barPadding), 
        showLine) {
            var negativeColors = new $.jqplot.ColorGenerator(this.negativeSeriesColors), positiveColors = new $.jqplot.ColorGenerator(this.seriesColors), negativeColor = negativeColors.get(this.index);
            this.useNegativeColors || (negativeColor = opts.fillStyle);
            var base, xstart, ystart, positiveColor = opts.fillStyle;
            if ("vertical" == this.barDirection) {
                for (var i = 0; i < gridData.length; i++) if (this._stack || null != this.data[i][1]) {
                    if (points = [], base = gridData[i][0] + this._barNudge, ystart = this._stack && this._prevGridData.length ? getStart(this.index, i, this._plotData[i][1], plot, "y") : this.fillToZero ? this._yaxis.series_u2p(0) : this.waterfall && i > 0 && i < this.gridData.length - 1 ? this.gridData[i - 1][1] : this.waterfall && 0 == i && i < this.gridData.length - 1 ? this._yaxis.min <= 0 && this._yaxis.max >= 0 ? this._yaxis.series_u2p(0) : this._yaxis.min > 0 ? ctx.canvas.height : 0 : this.waterfall && i == this.gridData.length - 1 ? this._yaxis.min <= 0 && this._yaxis.max >= 0 ? this._yaxis.series_u2p(0) : this._yaxis.min > 0 ? ctx.canvas.height : 0 : ctx.canvas.height, 
                    this.fillToZero && this._plotData[i][1] < 0 || this.waterfall && this._data[i][1] < 0 ? this.varyBarColor && !this._stack ? this.useNegativeColors ? opts.fillStyle = negativeColors.next() : opts.fillStyle = positiveColors.next() : opts.fillStyle = negativeColor : this.varyBarColor && !this._stack ? opts.fillStyle = positiveColors.next() : opts.fillStyle = positiveColor, 
                    !this.fillToZero || this._plotData[i][1] >= 0 ? (points.push([ base - this.barWidth / 2, ystart ]), 
                    points.push([ base - this.barWidth / 2, gridData[i][1] ]), points.push([ base + this.barWidth / 2, gridData[i][1] ]), 
                    points.push([ base + this.barWidth / 2, ystart ])) : (points.push([ base - this.barWidth / 2, gridData[i][1] ]), 
                    points.push([ base - this.barWidth / 2, ystart ]), points.push([ base + this.barWidth / 2, ystart ]), 
                    points.push([ base + this.barWidth / 2, gridData[i][1] ])), this._barPoints.push(points), 
                    shadow && !this._stack) {
                        var sopts = $.extend(!0, {}, opts);
                        delete sopts.fillStyle, this.renderer.shadowRenderer.draw(ctx, points, sopts);
                    }
                    var clr = opts.fillStyle || this.color;
                    this._dataColors.push(clr), this.renderer.shapeRenderer.draw(ctx, points, opts);
                }
            } else if ("horizontal" == this.barDirection) for (var i = 0; i < gridData.length; i++) if (this._stack || null != this.data[i][0]) {
                if (points = [], base = gridData[i][1] - this._barNudge, xstart = this._stack && this._prevGridData.length ? getStart(this.index, i, this._plotData[i][0], plot, "x") : this.fillToZero ? this._xaxis.series_u2p(0) : this.waterfall && i > 0 && i < this.gridData.length - 1 ? this.gridData[i - 1][0] : this.waterfall && 0 == i && i < this.gridData.length - 1 ? this._xaxis.min <= 0 && this._xaxis.max >= 0 ? this._xaxis.series_u2p(0) : (this._xaxis.min > 0, 
                0) : this.waterfall && i == this.gridData.length - 1 ? this._xaxis.min <= 0 && this._xaxis.max >= 0 ? this._xaxis.series_u2p(0) : this._xaxis.min > 0 ? 0 : ctx.canvas.width : 0, 
                this.fillToZero && this._plotData[i][0] < 0 || this.waterfall && this._data[i][0] < 0 ? this.varyBarColor && !this._stack ? this.useNegativeColors ? opts.fillStyle = negativeColors.next() : opts.fillStyle = positiveColors.next() : opts.fillStyle = negativeColor : this.varyBarColor && !this._stack ? opts.fillStyle = positiveColors.next() : opts.fillStyle = positiveColor, 
                !this.fillToZero || this._plotData[i][0] >= 0 ? (points.push([ xstart, base + this.barWidth / 2 ]), 
                points.push([ xstart, base - this.barWidth / 2 ]), points.push([ gridData[i][0], base - this.barWidth / 2 ]), 
                points.push([ gridData[i][0], base + this.barWidth / 2 ])) : (points.push([ gridData[i][0], base + this.barWidth / 2 ]), 
                points.push([ gridData[i][0], base - this.barWidth / 2 ]), points.push([ xstart, base - this.barWidth / 2 ]), 
                points.push([ xstart, base + this.barWidth / 2 ])), this._barPoints.push(points), 
                shadow && !this._stack) {
                    var sopts = $.extend(!0, {}, opts);
                    delete sopts.fillStyle, this.renderer.shadowRenderer.draw(ctx, points, sopts);
                }
                var clr = opts.fillStyle || this.color;
                this._dataColors.push(clr), this.renderer.shapeRenderer.draw(ctx, points, opts);
            }
        }
        if (0 == this.highlightColors.length) this.highlightColors = $.jqplot.computeHighlightColors(this._dataColors); else if ("string" == typeof this.highlightColors) {
            var temp = this.highlightColors;
            this.highlightColors = [];
            for (var i = 0; i < this._dataColors.length; i++) this.highlightColors.push(temp);
        }
    }, $.jqplot.BarRenderer.prototype.drawShadow = function(ctx, gridData, options, plot) {
        var i, points, nvals, nseries, pos, opts = void 0 != options ? options : {}, showLine = (void 0 != opts.shadow ? opts.shadow : this.shadow, 
        void 0 != opts.showLine ? opts.showLine : this.showLine);
        void 0 != opts.fill ? opts.fill : this.fill, this.xaxis, this.yaxis, this._xaxis.series_u2p, 
        this._yaxis.series_u2p;
        if (this._stack && this.shadow) {
            null == this.barWidth && this.renderer.setBarWidth.call(this);
            var temp = this._plotSeriesInfo = this.renderer.calcSeriesNumbers.call(this);
            if (nvals = temp[0], nseries = temp[1], pos = temp[2], this._stack ? this._barNudge = 0 : this._barNudge = (-Math.abs(nseries / 2 - .5) + pos) * (this.barWidth + this.barPadding), 
            showLine) if ("vertical" == this.barDirection) {
                for (var i = 0; i < gridData.length; i++) if (null != this.data[i][1]) {
                    points = [];
                    var ystart, base = gridData[i][0] + this._barNudge;
                    ystart = this._stack && this._prevGridData.length ? getStart(this.index, i, this._plotData[i][1], plot, "y") : this.fillToZero ? this._yaxis.series_u2p(0) : ctx.canvas.height, 
                    points.push([ base - this.barWidth / 2, ystart ]), points.push([ base - this.barWidth / 2, gridData[i][1] ]), 
                    points.push([ base + this.barWidth / 2, gridData[i][1] ]), points.push([ base + this.barWidth / 2, ystart ]), 
                    this.renderer.shadowRenderer.draw(ctx, points, opts);
                }
            } else if ("horizontal" == this.barDirection) for (var i = 0; i < gridData.length; i++) if (null != this.data[i][0]) {
                points = [];
                var xstart, base = gridData[i][1] - this._barNudge;
                xstart = this._stack && this._prevGridData.length ? getStart(this.index, i, this._plotData[i][0], plot, "x") : this.fillToZero ? this._xaxis.series_u2p(0) : 0, 
                points.push([ xstart, base + this.barWidth / 2 ]), points.push([ gridData[i][0], base + this.barWidth / 2 ]), 
                points.push([ gridData[i][0], base - this.barWidth / 2 ]), points.push([ xstart, base - this.barWidth / 2 ]), 
                this.renderer.shadowRenderer.draw(ctx, points, opts);
            }
        }
    };
}(jQuery);
//# sourceMappingURL=jqplot.barRenderer.min.js.map