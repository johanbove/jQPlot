!function($) {
    "use strict";
    var setTooltipPosition = function(location, gridpos, plot) {
        var x, y, c = plot.plugins.cursor, elem = c._tooltipElem;
        switch (location) {
          case "nw":
            x = gridpos.x + plot._gridPadding.left - elem.outerWidth(!0) - c.tooltipOffset, 
            y = gridpos.y + plot._gridPadding.top - c.tooltipOffset - elem.outerHeight(!0);
            break;

          case "n":
            x = gridpos.x + plot._gridPadding.left - elem.outerWidth(!0) / 2, y = gridpos.y + plot._gridPadding.top - c.tooltipOffset - elem.outerHeight(!0);
            break;

          case "ne":
            x = gridpos.x + plot._gridPadding.left + c.tooltipOffset, y = gridpos.y + plot._gridPadding.top - c.tooltipOffset - elem.outerHeight(!0);
            break;

          case "e":
            x = gridpos.x + plot._gridPadding.left + c.tooltipOffset, y = gridpos.y + plot._gridPadding.top - elem.outerHeight(!0) / 2;
            break;

          case "se":
            x = gridpos.x + plot._gridPadding.left + c.tooltipOffset, y = gridpos.y + plot._gridPadding.top + c.tooltipOffset;
            break;

          case "s":
            x = gridpos.x + plot._gridPadding.left - elem.outerWidth(!0) / 2, y = gridpos.y + plot._gridPadding.top + c.tooltipOffset;
            break;

          case "sw":
            x = gridpos.x + plot._gridPadding.left - elem.outerWidth(!0) - c.tooltipOffset, 
            y = gridpos.y + plot._gridPadding.top + c.tooltipOffset;
            break;

          case "w":
            x = gridpos.x + plot._gridPadding.left - elem.outerWidth(!0) - c.tooltipOffset, 
            y = gridpos.y + plot._gridPadding.top - elem.outerHeight(!0) / 2;
            break;

          default:
            x = gridpos.x + plot._gridPadding.left + c.tooltipOffset, y = gridpos.y + plot._gridPadding.top + c.tooltipOffset;
        }
        elem.css({
            left: x,
            top: y
        }), elem = null;
    }, resetSelection = function() {
        var sel;
        window.getSelection ? (sel = window.getSelection(), sel.empty ? sel.empty() : sel.removeAllRanges && sel.removeAllRanges()) : document.selection && document.selection.empty();
    }, getIntersectingPoints = function(plot, x, y) {
        var s, i, j, r, p, threshold, ret = {
            indices: [],
            data: []
        }, c = plot.plugins.cursor, seriesLen = plot.series.length, gridDataLen = 0;
        for (i = 0; seriesLen > i; i++) if (s = plot.series[i], r = s.renderer, s.show) for (threshold = c.intersectionThreshold, 
        s.showMarker && (threshold += s.markerRenderer.size / 2), gridDataLen = s.gridData.length, 
        j = 0; gridDataLen > j; j++) p = s.gridData[j], c.showVerticalLine && Math.abs(x - p[0]) <= threshold && (ret.indices.push(i), 
        ret.data.push({
            seriesIndex: i,
            pointIndex: j,
            gridData: p,
            data: s.data[j]
        }));
        return ret;
    }, updateTooltip = function(gridpos, datapos, plot) {
        var serie, data, g, i, j, tooltipAxisGroupLen, serieIndex, af, afstr, yaxisStr, xaxisStr, sx, sy, yfstr, xfstr, ret, idx, label, cellid, c = plot.plugins.cursor, series = plot.series, seriesLen = series.length, s = "", addbr = !1;
        if (c.showTooltipGridPosition && (s = gridpos.x + ", " + gridpos.y, addbr = !0), 
        c.showTooltipUnitPosition) for (i = 0, tooltipAxisGroupLen = c.tooltipAxisGroups.length; tooltipAxisGroupLen > i; i++) {
            if (serieIndex = i, g = c.tooltipAxisGroups[i], addbr) s += "<br />"; else for (j = 0; j < g.length; j++) j && (s += ", "), 
            af = plot.axes[g[j]]._ticks[0].formatter, afstr = plot.axes[g[j]]._ticks[0].formatString, 
            s += af(afstr, datapos[g[j]]);
            if (c.yaxis || c.xaxis) c.yaxis && c.yaxis.formatter ? yaxisStr = c.yaxis.formatter(series[i]._yaxis._ticks[0].formatString, datapos[g[1]], serieIndex) : (yfstr = g._yaxis._ticks[0].formatString, 
            sx = g._yaxis._ticks[0].formatter(yfstr, data[1], serieIndex)), c.xaxis && c.xaxis.formatter ? xaxisStr = c.xaxis.formatter(series[i]._xaxis._ticks[0].formatString, datapos[g[0]], serieIndex) : (xfstr = g._xaxis._ticks[0].formatString, 
            sx = g._xaxis._ticks[0].formatter(xfstr, data[0], serieIndex)), s += $.jqplot.sprintf(c.tooltipFormatString, xaxisStr, yaxisStr); else if (c.useAxesFormatters) for (j = 0; j < g.length; j++) j && (s += ", "), 
            af = plot.axes[g[j]]._ticks[0].formatter, afstr = plot.axes[g[j]]._ticks[0].formatString, 
            s += af(afstr, datapos[g[j]], serieIndex); else s += $.jqplot.sprintf(c.tooltipFormatString, datapos[g[0]], datapos[g[1]]);
            addbr = !0;
        }
        if (c.showTooltipDataPosition) for (ret = getIntersectingPoints(plot, gridpos.x, gridpos.y), 
        i = 0; seriesLen > i; i++) serieIndex = i, serie = series[i], serie.show && (idx = serie.index, 
        label = serie.label.toString(), c.useSeriesColor && (label = $.jqplot.sprintf('<span style="color:%s">%s</span>', serie.color, label)), 
        cellid = $.inArray(idx, ret.indices), sx = null, sy = null, -1 !== cellid && (data = ret.data[cellid].data, 
        c.yaxis || c.xaxis ? (c.yaxis && c.yaxis.formatter ? sy = c.yaxis.formatter(serie._yaxis._ticks[0].formatString, data[1], serieIndex) : (yfstr = serie._yaxis._ticks[0].formatString, 
        sy = serie._yaxis._ticks[0].formatter(yfstr, data[1], serieIndex)), c.xaxis && c.xaxis.formatter ? sx = c.xaxis.formatter(serie._xaxis._ticks[0].formatString, data[0], serieIndex) : (xfstr = serie._xaxis._ticks[0].formatString, 
        sx = serie._xaxis._ticks[0].formatter(xfstr, data[0], serieIndex)), !addbr && c.insertHead && (s += $.jqplot.sprintf(c.headTooltipFormatString, sx, sy), 
        s += "<br />")) : c.useAxesFormatters ? (xfstr = serie._xaxis._ticks[0].formatString, 
        yfstr = serie._yaxis._ticks[0].formatString, sx = serie._xaxis._ticks[0].formatter(xfstr, data[0], serieIndex), 
        sy = serie._yaxis._ticks[0].formatter(yfstr, data[1], serieIndex), !addbr && c.insertHead && (s += $.jqplot.sprintf(c.headTooltipFormatString, sx, sy), 
        s += "<br />")) : (sx = data[0], sy = data[1]), addbr && (s += "<br />"), s += $.jqplot.sprintf(c.tooltipFormatString, label, sx, sy), 
        addbr = !0));
        "" === s ? c._tooltipElem.css({
            display: "none"
        }) : c._tooltipElem.css({
            display: "block"
        }), c._tooltipElem.html(s);
    }, convertToShapeOption = function(option) {
        if (option) {
            var output = {};
            return option.color && (output.strokeStyle = option.color), option.style && (output.linePattern = option.style), 
            option.lineWidth && (output.lineWidth = option.lineWidth), output;
        }
        return option;
    }, moveLine = function(gridpos, plot) {
        var ret, cells, i, optionsVertical, optionsHorizontal, idx, serie, series, label, data, cellid, sx, sy, yfstr, xfstr, xf, yf, c = plot.plugins.cursor, ctx = c.cursorCanvas._ctx;
        if (ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height), c.showVerticalLine && (optionsVertical = convertToShapeOption(c.verticalLine), 
        c.shapeRenderer.draw(ctx, [ [ gridpos.x, 0 ], [ gridpos.x, ctx.canvas.height ] ], optionsVertical)), 
        c.showHorizontalLine && (optionsHorizontal = convertToShapeOption(c.horizontalLine), 
        c.shapeRenderer.draw(ctx, [ [ 0, gridpos.y ], [ ctx.canvas.width, gridpos.y ] ], optionsHorizontal)), 
        ret = getIntersectingPoints(plot, gridpos.x, gridpos.y), c.showCursorLegend) for (cells = $(plot.targetId + " td.jqplot-cursor-legend-label"), 
        i = 0; i < cells.length; i++) serie = series[i], idx = $(cells[i]).data("seriesIndex"), 
        series = plot.series[idx], label = series.label.toString(), cellid = $.inArray(idx, ret.indices), 
        sx = null, sy = null, -1 !== cellid && (data = ret.data[cellid].data, c.yaxis || c.xaxis ? (c.yaxis && c.yaxis.formatter ? sy = c.yaxis.formatter(serie._yaxis._ticks[0].formatString, data[1], idx) : (yfstr = series._yaxis._ticks[0].formatString, 
        sy = series._yaxis._ticks[0].formatter(yfstr, data[1], idx)), c.xaxis && c.xaxis.formatter ? sx = c.xaxis.formatter(serie._xaxis._ticks[0].formatString, data[0], idx) : (xfstr = series._xaxis._ticks[0].formatString, 
        sx = series._xaxis._ticks[0].formatter(xfstr, data[0], idx))) : c.useAxesFormatters ? (xf = series._xaxis._ticks[0].formatter, 
        yf = series._yaxis._ticks[0].formatter, xfstr = series._xaxis._ticks[0].formatString, 
        yfstr = series._yaxis._ticks[0].formatString, sx = xf(xfstr, data[0], idx), sy = yf(yfstr, data[1], idx)) : (sx = data[0], 
        sy = data[1])), plot.legend.escapeHtml ? $(cells[i]).text($.jqplot.sprintf(c.cursorLegendFormatString, label, sx, sy)) : $(cells[i]).html($.jqplot.sprintf(c.cursorLegendFormatString, label, sx, sy));
        ctx = null;
    }, moveTooltip = function(gridpos, plot, ev) {
        var x, y, xPosition, yPosition, c = plot.plugins.cursor, elem = c._tooltipElem, fallbackTooltipLocation = null;
        switch (c.tooltipLocation) {
          case "nw":
            x = gridpos.x + plot._gridPadding.left - elem.outerWidth(!0) - c.tooltipOffset, 
            y = gridpos.y + plot._gridPadding.top - c.tooltipOffset - elem.outerHeight(!0);
            break;

          case "n":
            x = gridpos.x + plot._gridPadding.left - elem.outerWidth(!0) / 2, y = gridpos.y + plot._gridPadding.top - c.tooltipOffset - elem.outerHeight(!0);
            break;

          case "ne":
            x = gridpos.x + plot._gridPadding.left + c.tooltipOffset, y = gridpos.y + plot._gridPadding.top - c.tooltipOffset - elem.outerHeight(!0);
            break;

          case "e":
            x = gridpos.x + plot._gridPadding.left + c.tooltipOffset, y = gridpos.y + plot._gridPadding.top - elem.outerHeight(!0) / 2;
            break;

          case "se":
            x = gridpos.x + plot._gridPadding.left + c.tooltipOffset, y = gridpos.y + plot._gridPadding.top + c.tooltipOffset;
            break;

          case "s":
            x = gridpos.x + plot._gridPadding.left - elem.outerWidth(!0) / 2, y = gridpos.y + plot._gridPadding.top + c.tooltipOffset;
            break;

          case "sw":
            x = gridpos.x + plot._gridPadding.left - elem.outerWidth(!0) - c.tooltipOffset, 
            y = gridpos.y + plot._gridPadding.top + c.tooltipOffset;
            break;

          case "w":
            x = gridpos.x + plot._gridPadding.left - elem.outerWidth(!0) - c.tooltipOffset, 
            y = gridpos.y + plot._gridPadding.top - elem.outerHeight(!0) / 2;
            break;

          default:
            x = gridpos.x + plot._gridPadding.left + c.tooltipOffset, y = gridpos.y + plot._gridPadding.top + c.tooltipOffset;
        }
        return c.constrainTooltipToScreen && "undefined" != typeof ev && (xPosition = "", 
        yPosition = "", yPosition += c.tooltipLocation[0], xPosition += c.tooltipLocation.length > 1 ? c.tooltipLocation[1] : c.tooltipLocation[0], 
        "n" === yPosition && ev.pageY - c.tooltipOffset - elem.outerHeight(!0) <= 0 ? fallbackTooltipLocation = "s" : "s" === yPosition && ev.pageY + elem.outerHeight(!0) + c.tooltipOffset >= document.body.clientHeight ? fallbackTooltipLocation = "n" : ("n" === yPosition || "s" === yPosition) && (fallbackTooltipLocation = yPosition), 
        "w" === xPosition && ev.pageX - elem.outerWidth(!0) <= 0 ? fallbackTooltipLocation += "e" : "e" === xPosition && ev.pageX + elem.outerWidth(!0) >= document.body.clientWidth ? fallbackTooltipLocation += "w" : ("e" === xPosition || "w" === xPosition) && (fallbackTooltipLocation += xPosition), 
        null !== fallbackTooltipLocation) ? void setTooltipPosition(fallbackTooltipLocation, gridpos, plot) : (elem.css({
            left: x,
            top: y
        }), void (elem = null));
    }, positionTooltip = function(plot) {
        var a, b, grid = plot._gridPadding, c = plot.plugins.cursor, elem = c._tooltipElem;
        switch (c.tooltipLocation) {
          case "nw":
            a = grid.left + c.tooltipOffset, b = grid.top + c.tooltipOffset, elem.css({
                left: a,
                top: b
            });
            break;

          case "n":
            a = (grid.left + (plot._plotDimensions.width - grid.right)) / 2 - elem.outerWidth(!0) / 2, 
            b = grid.top + c.tooltipOffset, elem.css({
                left: a,
                top: b
            });
            break;

          case "ne":
            a = grid.right + c.tooltipOffset, b = grid.top + c.tooltipOffset, elem.css({
                right: a,
                top: b
            });
            break;

          case "e":
            a = grid.right + c.tooltipOffset, b = (grid.top + (plot._plotDimensions.height - grid.bottom)) / 2 - elem.outerHeight(!0) / 2, 
            elem.css({
                right: a,
                top: b
            });
            break;

          case "se":
            a = grid.right + c.tooltipOffset, b = grid.bottom + c.tooltipOffset, elem.css({
                right: a,
                bottom: b
            });
            break;

          case "s":
            a = (grid.left + (plot._plotDimensions.width - grid.right)) / 2 - elem.outerWidth(!0) / 2, 
            b = grid.bottom + c.tooltipOffset, elem.css({
                left: a,
                bottom: b
            });
            break;

          case "sw":
            a = grid.left + c.tooltipOffset, b = grid.bottom + c.tooltipOffset, elem.css({
                left: a,
                bottom: b
            });
            break;

          case "w":
            a = grid.left + c.tooltipOffset, b = (grid.top + (plot._plotDimensions.height - grid.bottom)) / 2 - elem.outerHeight(!0) / 2, 
            elem.css({
                left: a,
                top: b
            });
            break;

          default:
            a = grid.right - c.tooltipOffset, b = grid.bottom + c.tooltipOffset, elem.css({
                right: a,
                bottom: b
            });
        }
        elem = null;
    }, handleClick = function(ev, gridpos, datapos, neighbor, plot) {
        ev.preventDefault(), ev.stopImmediatePropagation();
        var c = plot.plugins.cursor;
        return c.clickReset && c.resetZoom(plot, c), resetSelection(), !1;
    }, handleDblClick = function(ev, gridpos, datapos, neighbor, plot) {
        ev.preventDefault(), ev.stopImmediatePropagation();
        var c = plot.plugins.cursor;
        return c.dblClickReset && c.resetZoom(plot, c), resetSelection(), !1;
    }, handleMouseLeave = function(ev, gridpos, datapos, neighbor, plot) {
        var cells, i, idx, ctx, series, label, c = plot.plugins.cursor;
        if (c.onGrid = !1, c.show && ($(ev.target).css("cursor", c.previousCursor), !c.showTooltip || c._zoom.zooming && c.showTooltipOutsideZoom && !c.constrainOutsideZoom || (c._tooltipElem.empty(), 
        c._tooltipElem.hide()), c.zoom && (c._zoom.gridpos = gridpos, c._zoom.datapos = datapos), 
        (c.showVerticalLine || c.showHorizontalLine) && (ctx = c.cursorCanvas._ctx, ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height), 
        ctx = null), c.showCursorLegend)) for (cells = $(plot.targetId + " td.jqplot-cursor-legend-label"), 
        i = 0; i < cells.length; i++) idx = $(cells[i]).data("seriesIndex"), series = plot.series[idx], 
        label = series.label.toString(), plot.legend.escapeHtml ? $(cells[i]).text($.jqplot.sprintf(c.cursorLegendFormatString, label, void 0, void 0)) : $(cells[i]).html($.jqplot.sprintf(c.cursorLegendFormatString, label, void 0, void 0));
    }, handleMouseEnter = function(ev, gridpos, datapos, neighbor, plot) {
        var c = plot.plugins.cursor;
        c.onGrid = !0, c.show && (c.previousCursor = ev.target.style.cursor, ev.target.style.cursor = c.style, 
        c.showTooltip && (updateTooltip(gridpos, datapos, plot), c.followMouse ? moveTooltip(gridpos, plot, ev) : positionTooltip(plot), 
        c._tooltipElem.show()), (c.showVerticalLine || c.showHorizontalLine) && moveLine(gridpos, plot));
    }, handleMouseMove = function(ev, gridpos, datapos, neighbor, plot) {
        var c = plot.plugins.cursor;
        c.show && (c.showTooltip && (updateTooltip(gridpos, datapos, plot), c.followMouse && moveTooltip(gridpos, plot, ev)), 
        (c.showVerticalLine || c.showHorizontalLine) && moveLine(gridpos, plot));
    }, getEventPosition = function(ev) {
        var dataPos, an, ax, n, axis, plot = ev.data.plot, go = plot.eventCanvas._elem.offset(), gridPos = {
            x: ev.pageX - go.left,
            y: ev.pageY - go.top
        };
        for (dataPos = {
            xaxis: null,
            yaxis: null,
            x2axis: null,
            y2axis: null,
            y3axis: null,
            y4axis: null,
            y5axis: null,
            y6axis: null,
            y7axis: null,
            y8axis: null,
            y9axis: null,
            yMidAxis: null
        }, an = [ "xaxis", "yaxis", "x2axis", "y2axis", "y3axis", "y4axis", "y5axis", "y6axis", "y7axis", "y8axis", "y9axis", "yMidAxis" ], 
        ax = plot.axes, n = 11; n > 0; n--) axis = an[n - 1], ax[axis].show && (dataPos[axis] = ax[axis].series_p2u(gridPos[axis.charAt(0)]));
        return {
            offsets: go,
            gridPos: gridPos,
            dataPos: dataPos
        };
    }, drawZoomBox = function() {
        var start, end, ctx, l, t, h, w;
        start = this._zoom.start, end = this._zoom.end, ctx = this.zoomCanvas._ctx, end[0] > start[0] ? (l = start[0], 
        w = end[0] - start[0]) : (l = end[0], w = start[0] - end[0]), end[1] > start[1] ? (t = start[1], 
        h = end[1] - start[1]) : (t = end[1], h = start[1] - end[1]), ctx.fillStyle = "rgba(0, 0, 0, 0.2)", 
        ctx.strokeStyle = "#999999", ctx.lineWidth = 1, ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height), 
        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height), ctx.clearRect(l, t, w, h), 
        ctx.strokeRect(l, t, w, h), ctx = null;
    }, handleZoomMove = function(ev) {
        var ctx, positions, gridpos, datapos, xpos, ypos, height, width, plot = ev.data.plot, c = plot.plugins.cursor;
        c.show && c.zoom && c._zoom.started && !c.zoomTarget && (ev.preventDefault(), ctx = c.zoomCanvas._ctx, 
        positions = getEventPosition(ev), gridpos = positions.gridPos, datapos = positions.dataPos, 
        c._zoom.gridpos = gridpos, c._zoom.datapos = datapos, c._zoom.zooming = !0, xpos = gridpos.x, 
        ypos = gridpos.y, height = ctx.canvas.height, width = ctx.canvas.width, c.showTooltip && !c.onGrid && c.showTooltipOutsideZoom && (updateTooltip(gridpos, datapos, plot), 
        c.followMouse && moveTooltip(gridpos, plot, ev)), "x" === c.constrainZoomTo ? c._zoom.end = [ xpos, height ] : "y" === c.constrainZoomTo ? c._zoom.end = [ width, ypos ] : c._zoom.end = [ xpos, ypos ], 
        resetSelection(), drawZoomBox.call(c), ctx = null);
    }, handleMouseUp = function(ev) {
        var xpos, ypos, datapos, height, width, axes, axis, plot = ev.data.plot, c = plot.plugins.cursor;
        if (c.zoom && c._zoom.zooming && !c.zoomTarget) {
            if (xpos = c._zoom.gridpos.x, ypos = c._zoom.gridpos.y, datapos = c._zoom.datapos, 
            height = c.zoomCanvas._ctx.canvas.height, width = c.zoomCanvas._ctx.canvas.width, 
            axes = plot.axes, c.constrainOutsideZoom && !c.onGrid) {
                0 > xpos ? xpos = 0 : xpos > width && (xpos = width), 0 > ypos ? ypos = 0 : ypos > height && (ypos = height);
                for (axis in datapos) datapos.hasOwnProperty(axis) && datapos[axis] && ("x" === axis.charAt(0) ? datapos[axis] = axes[axis].series_p2u(xpos) : datapos[axis] = axes[axis].series_p2u(ypos));
            }
            "x" === c.constrainZoomTo ? ypos = height : "y" === c.constrainZoomTo && (xpos = width), 
            c._zoom.end = [ xpos, ypos ], c._zoom.gridpos = {
                x: xpos,
                y: ypos
            }, c.doZoom(c._zoom.gridpos, datapos, plot, c);
        }
        c._zoom.started = !1, c._zoom.zooming = !1, $(document).unbind("mousemove.jqplotCursor", handleZoomMove), 
        document.onselectstart && null !== c._oldHandlers.onselectstart && (document.onselectstart = c._oldHandlers.onselectstart, 
        c._oldHandlers.onselectstart = null), document.ondrag && null !== c._oldHandlers.ondrag && (document.ondrag = c._oldHandlers.ondrag, 
        c._oldHandlers.ondrag = null), document.onmousedown && null !== c._oldHandlers.onmousedown && (document.onmousedown = c._oldHandlers.onmousedown, 
        c._oldHandlers.onmousedown = null);
    }, handleMouseDown = function(ev, gridpos, datapos, neighbor, plot) {
        var ctx, ax, c = plot.plugins.cursor;
        plot.axes;
        if (plot.plugins.mobile ? $(document).one("vmouseup.jqplot_cursor", {
            plot: plot
        }, handleMouseUp) : $(document).one("mouseup.jqplot_cursor", {
            plot: plot
        }, handleMouseUp), document.onselectstart && (c._oldHandlers.onselectstart = document.onselectstart, 
        document.onselectstart = function() {
            return !1;
        }), document.ondrag && (c._oldHandlers.ondrag = document.ondrag, document.ondrag = function() {
            return !1;
        }), document.onmousedown && (c._oldHandlers.onmousedown = document.onmousedown, 
        document.onmousedown = function() {
            return !1;
        }), c.zoom) {
            c.zoomProxy || (ctx = c.zoomCanvas._ctx, ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height), 
            ctx = null), "x" === c.constrainZoomTo ? c._zoom.start = [ gridpos.x, 0 ] : "y" === c.constrainZoomTo ? c._zoom.start = [ 0, gridpos.y ] : c._zoom.start = [ gridpos.x, gridpos.y ], 
            c._zoom.started = !0;
            for (ax in datapos) datapos.hasOwnProperty(ax) && (c._zoom.axes.start[ax] = datapos[ax]);
            plot.plugins.mobile ? $(document).bind("vmousemove.jqplotCursor", {
                plot: plot
            }, handleZoomMove) : $(document).bind("mousemove.jqplotCursor", {
                plot: plot
            }, handleZoomMove);
        }
    };
    $.jqplot.Cursor = function(options) {
        this.style = "crosshair", this.previousCursor = "auto", this.constrainTooltipToScreen = !1, 
        this.show = $.jqplot.config.enablePlugins, this.showTooltip = !0, this.followMouse = !1, 
        this.tooltipLocation = "se", this.tooltipOffset = 6, this.showTooltipGridPosition = !1, 
        this.showTooltipUnitPosition = !0, this.showTooltipDataPosition = !1, this.tooltipFormatString = "%.4P, %.4P", 
        this.useAxesFormatters = !0, this.tooltipAxisGroups = [], this.zoom = !1, this.zoomProxy = !1, 
        this.zoomTarget = !1, this.looseZoom = !0, this.clickReset = !1, this.dblClickReset = !0, 
        this.showVerticalLine = !1, this.showHorizontalLine = !1, this.constrainZoomTo = "none", 
        this.shapeRenderer = new $.jqplot.ShapeRenderer(), this._zoom = {
            start: [],
            end: [],
            started: !1,
            zooming: !1,
            isZoomed: !1,
            axes: {
                start: {},
                end: {}
            },
            gridpos: {},
            datapos: {}
        }, this._tooltipElem = null, this.zoomCanvas = null, this.cursorCanvas = null, this.intersectionThreshold = 2, 
        this.showCursorLegend = !1, this.cursorLegendFormatString = $.jqplot.Cursor.cursorLegendFormatString, 
        this._oldHandlers = {
            onselectstart: null,
            ondrag: null,
            onmousedown: null
        }, this.constrainOutsideZoom = !0, this.showTooltipOutsideZoom = !1, this.onGrid = !1, 
        this.verticalLine = null, this.horizontalLine = null, this.insertHead = !1, this.headTooltipFormatString = "%s", 
        this.useSeriesColor = !1, this.yaxis = null, this.xaxis = null, $.extend(!0, this, options);
    }, $.jqplot.Cursor.cursorLegendFormatString = "%s x:%s, y:%s", $.jqplot.Cursor.init = function(target, data, opts) {
        var c, options = opts || {};
        this.plugins.cursor = new $.jqplot.Cursor(options.cursor), c = this.plugins.cursor, 
        c.show && (this.eventListenerHooks.addOnce("jqplotMouseEnter", handleMouseEnter), 
        this.eventListenerHooks.addOnce("jqplotMouseLeave", handleMouseLeave), this.eventListenerHooks.addOnce("jqplotMouseMove", handleMouseMove), 
        c.showCursorLegend && (opts.legend = opts.legend || {}, opts.legend.renderer = $.jqplot.CursorLegendRenderer, 
        opts.legend.formatString = this.plugins.cursor.cursorLegendFormatString, opts.legend.show = !0), 
        c.zoom && (this.eventListenerHooks.addOnce("jqplotMouseDown", handleMouseDown), 
        c.clickReset && this.eventListenerHooks.addOnce("jqplotClick", handleClick), c.dblClickReset && this.eventListenerHooks.addOnce("jqplotDblClick", handleDblClick)), 
        this.resetZoom = function() {
            var ax, ctx, axes = this.axes;
            if (c.zoomProxy) ctx = this.plugins.cursor.zoomCanvas._ctx, ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height), 
            ctx = null; else {
                for (ax in axes) axes.hasOwnProperty(ax) && (axes[ax].reset(), axes[ax]._ticks = [], 
                void 0 !== c._zoom.axes[ax] && (axes[ax]._autoFormatString = c._zoom.axes[ax].tickFormatString));
                this.redraw();
            }
            this.plugins.cursor._zoom.isZoomed = !1, this.target.trigger("jqplotResetZoom", [ this, this.plugins.cursor ]);
        }, c.showTooltipDataPosition && (c.showTooltipUnitPosition = !1, c.showTooltipGridPosition = !1, 
        "undefined" == typeof options.cursor.tooltipFormatString && (c.tooltipFormatString = $.jqplot.Cursor.cursorLegendFormatString)));
    }, $.jqplot.Cursor.postDraw = function() {
        var series, s, i, l, ax, c = this.plugins.cursor, elem = document.createElement("div"), temp = [];
        if (c.zoomCanvas && (c.zoomCanvas.resetCanvas(), c.zoomCanvas = null), c.cursorCanvas && (c.cursorCanvas.resetCanvas(), 
        c.cursorCanvas = null), c._tooltipElem && (c._tooltipElem.emptyForce(), c._tooltipElem = null), 
        c.zoom && (c.zoomCanvas = new $.jqplot.GenericCanvas(), this.eventCanvas._elem.before(c.zoomCanvas.createElement(this._gridPadding, "jqplot-zoom-canvas", this._plotDimensions, this)), 
        c.zoomCanvas.setContext()), c._tooltipElem = $(elem), elem = null, c._tooltipElem.addClass("jqplot-cursor-tooltip"), 
        c._tooltipElem.css({
            position: "absolute",
            display: "none"
        }), c.zoomCanvas ? c.zoomCanvas._elem.before(c._tooltipElem) : this.eventCanvas._elem.before(c._tooltipElem), 
        (c.showVerticalLine || c.showHorizontalLine) && (c.cursorCanvas = new $.jqplot.GenericCanvas(), 
        this.eventCanvas._elem.before(c.cursorCanvas.createElement(this._gridPadding, "jqplot-cursor-canvas", this._plotDimensions, this)), 
        c.cursorCanvas.setContext()), c.showTooltipUnitPosition && 0 === c.tooltipAxisGroups.length) {
            for (series = this.series, i = 0, l = series.length; l > i; i++) s = series[i], 
            ax = s.xaxis + "," + s.yaxis, -1 === $.inArray(ax, temp) && temp.push(ax);
            for (i = 0, l = temp.length; l > i; i++) c.tooltipAxisGroups.push(temp[i].split(","));
        }
    }, $.jqplot.Cursor.zoomProxy = function(targetPlot, controllerPlot) {
        var tc = targetPlot.plugins.cursor, cc = controllerPlot.plugins.cursor, plotZoom = function(ev, gridpos, datapos, plot, cursor) {
            tc.doZoom(gridpos, datapos, targetPlot, cursor);
        }, plotReset = function(ev, plot, cursor) {
            targetPlot.resetZoom();
        };
        tc.zoomTarget = !0, tc.zoom = !0, tc.style = "auto", tc.dblClickReset = !1, cc.zoom = !0, 
        cc.zoomProxy = !0, controllerPlot.target.bind("jqplotZoom", plotZoom), controllerPlot.target.bind("jqplotResetZoom", plotReset);
    }, $.jqplot.Cursor.prototype.resetZoom = function(plot, cursor) {
        var ax, ctx, axes = plot.axes, cax = cursor._zoom.axes;
        if (!plot.plugins.cursor.zoomProxy && cursor._zoom.isZoomed) {
            for (ax in axes) axes.hasOwnProperty(ax) && (axes[ax].reset(), axes[ax]._ticks = [], 
            axes[ax]._autoFormatString = cax[ax].tickFormatString);
            plot.redraw(), cursor._zoom.isZoomed = !1;
        } else ctx = cursor.zoomCanvas._ctx, ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height), 
        ctx = null;
        plot.target.trigger("jqplotResetZoom", [ plot, cursor ]);
    }, $.jqplot.Cursor.resetZoom = function(plot) {
        plot.resetZoom();
    }, $.jqplot.Cursor.prototype.doZoom = function(gridpos, datapos, plot, cursor) {
        var dp, span, newmin, newmax, curax, _numberTicks, ret, ax, c = cursor, axes = plot.axes, zaxes = c._zoom.axes, start = zaxes.start, ctx = (zaxes.end, 
        plot.plugins.cursor.zoomCanvas._ctx);
        if ("none" === c.constrainZoomTo && Math.abs(gridpos.x - c._zoom.start[0]) > 6 && Math.abs(gridpos.y - c._zoom.start[1]) > 6 || "x" === c.constrainZoomTo && Math.abs(gridpos.x - c._zoom.start[0]) > 6 || "y" === c.constrainZoomTo && Math.abs(gridpos.y - c._zoom.start[1]) > 6) {
            if (!plot.plugins.cursor.zoomProxy) {
                for (ax in datapos) datapos.hasOwnProperty(ax) && ("undefined" == typeof c._zoom.axes[ax] && (c._zoom.axes[ax] = {}, 
                c._zoom.axes[ax].numberTicks = axes[ax].numberTicks, c._zoom.axes[ax].tickInterval = axes[ax].tickInterval, 
                c._zoom.axes[ax].daTickInterval = axes[ax].daTickInterval, c._zoom.axes[ax].min = axes[ax].min, 
                c._zoom.axes[ax].max = axes[ax].max, c._zoom.axes[ax].tickFormatString = null !== axes[ax].tickOptions ? axes[ax].tickOptions.formatString : ""), 
                ("none" === c.constrainZoomTo || "x" === c.constrainZoomTo && "x" === ax.charAt(0) || "y" === c.constrainZoomTo && "y" === ax.charAt(0)) && (dp = datapos[ax], 
                null !== dp && (dp > start[ax] ? (newmin = start[ax], newmax = dp) : (span = start[ax] - dp, 
                newmin = dp, newmax = start[ax]), curax = axes[ax], _numberTicks = null, curax.alignTicks && ("x2axis" === curax.name && plot.axes.xaxis.show ? _numberTicks = plot.axes.xaxis.numberTicks : "y" === curax.name.charAt(0) && "yaxis" !== curax.name && "yMidAxis" !== curax.name && plot.axes.yaxis.show && (_numberTicks = plot.axes.yaxis.numberTicks)), 
                !this.looseZoom || axes[ax].renderer.constructor !== $.jqplot.LinearAxisRenderer && axes[ax].renderer.constructor !== $.jqplot.LogAxisRenderer ? (axes[ax].min = newmin, 
                axes[ax].max = newmax, axes[ax].tickInterval = null, axes[ax].numberTicks = null, 
                axes[ax].daTickInterval = null) : (ret = $.jqplot.LinearTickGenerator(newmin, newmax, curax._scalefact, _numberTicks), 
                axes[ax].tickInset && ret[0] < axes[ax].min + axes[ax].tickInset * axes[ax].tickInterval && (ret[0] += ret[4], 
                ret[2] -= 1), axes[ax].tickInset && ret[1] > axes[ax].max - axes[ax].tickInset * axes[ax].tickInterval && (ret[1] -= ret[4], 
                ret[2] -= 1), axes[ax].renderer.constructor === $.jqplot.LogAxisRenderer && ret[0] < axes[ax].min && (ret[0] += ret[4], 
                ret[2] -= 1), axes[ax].min = ret[0], axes[ax].max = ret[1], axes[ax]._autoFormatString = ret[3], 
                axes[ax].numberTicks = ret[2], axes[ax].tickInterval = ret[4], axes[ax].daTickInterval = [ ret[4] / 1e3, "seconds" ]), 
                axes[ax]._ticks = [])));
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height), plot.redraw(), c._zoom.isZoomed = !0, 
                ctx = null;
            }
            plot.target.trigger("jqplotZoom", [ gridpos, datapos, plot, cursor ]);
        }
    }, $.jqplot.Cursor.prototype.setZoom = function(posStart, posStop, plot) {
        var startEv, stopEv, gridpos, datapos, c, ax;
        startEv = {
            pageX: posStart.x,
            pageY: posStart.y,
            preventDefault: function() {
                console.log("prevent");
            },
            data: {
                plot: plot
            }
        }, stopEv = {
            pageX: posStop.x,
            pageY: posStop.y,
            preventDefault: function() {
                console.log("prevent");
            },
            data: {
                plot: plot
            }
        }, gridpos = getEventPosition(startEv).gridPos, datapos = getEventPosition(startEv).dataPos, 
        c = plot.plugins.cursor, "x" === c.constrainZoomTo ? c._zoom.start = [ gridpos.x, 0 ] : "y" === c.constrainZoomTo ? c._zoom.start = [ 0, gridpos.y ] : c._zoom.start = [ gridpos.x, gridpos.y ], 
        c._zoom.started = !0;
        for (ax in datapos) datapos.hasOwnProperty(ax) && (c._zoom.axes.start[ax] = datapos[ax]);
        plot.plugins.mobile ? $(document).bind("vmousemove.jqplotCursor", {
            plot: plot
        }, handleZoomMove) : $(document).bind("mousemove.jqplotCursor", {
            plot: plot
        }, handleZoomMove), handleMouseDown(startEv, gridpos, datapos, {}, plot), handleZoomMove(startEv), 
        handleMouseUp(stopEv);
    }, $.jqplot.preInitHooks.push($.jqplot.Cursor.init), $.jqplot.postDrawHooks.push($.jqplot.Cursor.postDraw), 
    $.jqplot.CursorLegendRenderer = function(options) {
        $.jqplot.TableLegendRenderer.call(this, options), this.formatString = "%s";
    }, $.jqplot.CursorLegendRenderer.prototype = new $.jqplot.TableLegendRenderer(), 
    $.jqplot.CursorLegendRenderer.prototype.constructor = $.jqplot.CursorLegendRenderer, 
    $.jqplot.CursorLegendRenderer.prototype.draw = function() {
        var series, elem, pad, i, j, seriesLen, s, lt, color, item, addrow = function(label, color, pad, idx) {
            var td, rs = pad ? this.rowSpacing : "0", tr = $('<tr class="jqplot-legend jqplot-cursor-legend"></tr>').appendTo(this._elem);
            tr.data("seriesIndex", idx), $('<td class="jqplot-legend jqplot-cursor-legend-swatch" style="padding-top:' + rs + ';"><div style="border:1px solid #cccccc;padding:0.2em;"><div class="jqplot-cursor-legend-swatch" style="background-color:' + color + ';"></div></div></td>').appendTo(tr), 
            td = $('<td class="jqplot-legend jqplot-cursor-legend-label" style="vertical-align:middle;padding-top:' + rs + ';"></td>'), 
            td.appendTo(tr), td.data("seriesIndex", idx), this.escapeHtml ? td.text(label) : td.html(label), 
            tr = null, td = null;
        };
        if (this._elem && (this._elem.emptyForce(), this._elem = null), this.show) {
            for (series = this._series, elem = document.createElement("table"), this._elem = $(elem), 
            elem = null, this._elem.addClass("jqplot-legend jqplot-cursor-legend"), this._elem.css("position", "absolute"), 
            pad = !1, i = 0, seriesLen = series.length; seriesLen > i; i++) if (s = series[i], 
            s.show && s.showLabel) for (lt = $.jqplot.sprintf(this.formatString, s.label.toString()), 
            lt && (color = s.color, s._stack && !s.fill && (color = ""), addrow.call(this, lt, color, pad, i), 
            pad = !0), j = 0; j < $.jqplot.addLegendRowHooks.length; j++) item = $.jqplot.addLegendRowHooks[j].call(this, s), 
            item && (addrow.call(this, item.label, item.color, pad), pad = !0);
            series = s = null;
        }
        return this._elem;
    };
}(jQuery);
//# sourceMappingURL=jqplot.cursor.min.js.map