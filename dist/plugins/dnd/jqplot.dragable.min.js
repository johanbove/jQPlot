!function($) {
    function DragCanvas() {
        $.jqplot.GenericCanvas.call(this), this.isDragging = !1, this.isOver = !1, this._neighbor, 
        this._cursors = [];
    }
    function initDragPoint(plot, neighbor) {
        var s = plot.series[neighbor.seriesIndex], drag = s.plugins.dragable, smr = s.markerRenderer, mr = drag.markerRenderer;
        if (mr.style = smr.style, mr.lineWidth = smr.lineWidth + 2.5, mr.size = smr.size + 5, 
        !drag.color) {
            var rgba = $.jqplot.getColorComponents(smr.color), newrgb = [ rgba[0], rgba[1], rgba[2] ], alpha = rgba[3] >= .6 ? .6 * rgba[3] : rgba[3] * (2 - rgba[3]);
            drag.color = "rgba(" + newrgb[0] + "," + newrgb[1] + "," + newrgb[2] + "," + alpha + ")";
        }
        mr.color = drag.color, mr.init();
        var start = neighbor.pointIndex > 0 ? neighbor.pointIndex - 1 : 0, end = neighbor.pointIndex + 2;
        drag._gridData = s.gridData.slice(start, end);
    }
    function handleMove(ev, gridpos, datapos, neighbor, plot) {
        if (plot.plugins.dragable.dragCanvas.isDragging) {
            var dc = plot.plugins.dragable.dragCanvas, dp = dc._neighbor, s = plot.series[dp.seriesIndex], drag = s.plugins.dragable, x = (s.gridData, 
            "y" == drag.constrainTo ? dp.gridData[0] : gridpos.x), y = "x" == drag.constrainTo ? dp.gridData[1] : gridpos.y, xu = s._xaxis.series_p2u(x), yu = s._yaxis.series_p2u(y), ctx = dc._ctx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height), dp.pointIndex > 0 ? drag._gridData[1] = [ x, y ] : drag._gridData[0] = [ x, y ], 
            plot.series[dp.seriesIndex].draw(dc._ctx, {
                gridData: drag._gridData,
                shadow: !1,
                preventJqPlotSeriesDrawTrigger: !0,
                color: drag.color,
                markerOptions: {
                    color: drag.color,
                    shadow: !1
                },
                trendline: {
                    show: !1
                }
            }), plot.target.trigger("jqplotSeriesPointChange", [ dp.seriesIndex, dp.pointIndex, [ xu, yu ], [ x, y ] ]);
        } else if (null != neighbor) {
            var series = plot.series[neighbor.seriesIndex];
            if (series.isDragable) {
                var dc = plot.plugins.dragable.dragCanvas;
                dc.isOver || (dc._cursors.push(ev.target.style.cursor), ev.target.style.cursor = "pointer"), 
                dc.isOver = !0;
            }
        } else if (null == neighbor) {
            var dc = plot.plugins.dragable.dragCanvas;
            dc.isOver && (ev.target.style.cursor = dc._cursors.pop(), dc.isOver = !1);
        }
    }
    function handleDown(ev, gridpos, datapos, neighbor, plot) {
        var dc = plot.plugins.dragable.dragCanvas;
        if (dc._cursors.push(ev.target.style.cursor), null != neighbor) {
            var s = plot.series[neighbor.seriesIndex], drag = s.plugins.dragable;
            s.isDragable && !dc.isDragging && (dc._neighbor = neighbor, dc.isDragging = !0, 
            initDragPoint(plot, neighbor), drag.markerRenderer.draw(s.gridData[neighbor.pointIndex][0], s.gridData[neighbor.pointIndex][1], dc._ctx), 
            ev.target.style.cursor = "move", plot.target.trigger("jqplotDragStart", [ neighbor.seriesIndex, neighbor.pointIndex, gridpos, datapos ]));
        } else {
            var ctx = dc._ctx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height), dc.isDragging = !1;
        }
    }
    function handleUp(ev, gridpos, datapos, neighbor, plot) {
        if (plot.plugins.dragable.dragCanvas.isDragging) {
            var dc = plot.plugins.dragable.dragCanvas, ctx = dc._ctx;
            ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height), dc.isDragging = !1;
            var dp = dc._neighbor, s = plot.series[dp.seriesIndex], drag = s.plugins.dragable, x = "y" == drag.constrainTo ? dp.data[0] : datapos[s.xaxis], y = "x" == drag.constrainTo ? dp.data[1] : datapos[s.yaxis];
            s.data[dp.pointIndex][0] = x, s.data[dp.pointIndex][1] = y, plot.drawSeries({
                preventJqPlotSeriesDrawTrigger: !0
            }, dp.seriesIndex), dc._neighbor = null, ev.target.style.cursor = dc._cursors.pop(), 
            plot.target.trigger("jqplotDragStop", [ gridpos, datapos ]);
        }
    }
    $.jqplot.Dragable = function(options) {
        this.markerRenderer = new $.jqplot.MarkerRenderer({
            shadow: !1
        }), this.shapeRenderer = new $.jqplot.ShapeRenderer(), this.isDragging = !1, this.isOver = !1, 
        this._ctx, this._elem, this._point, this._gridData, this.color, this.constrainTo = "none", 
        $.extend(!0, this, options);
    }, DragCanvas.prototype = new $.jqplot.GenericCanvas(), DragCanvas.prototype.constructor = DragCanvas, 
    $.jqplot.Dragable.parseOptions = function(defaults, opts) {
        var options = opts || {};
        this.plugins.dragable = new $.jqplot.Dragable(options.dragable), this.isDragable = $.jqplot.config.enablePlugins;
    }, $.jqplot.Dragable.postPlotDraw = function() {
        this.plugins.dragable && this.plugins.dragable.highlightCanvas && (this.plugins.dragable.highlightCanvas.resetCanvas(), 
        this.plugins.dragable.highlightCanvas = null), this.plugins.dragable = {
            previousCursor: "auto",
            isOver: !1
        }, this.plugins.dragable.dragCanvas = new DragCanvas(), this.eventCanvas._elem.before(this.plugins.dragable.dragCanvas.createElement(this._gridPadding, "jqplot-dragable-canvas", this._plotDimensions, this));
        this.plugins.dragable.dragCanvas.setContext();
    }, $.jqplot.preParseSeriesOptionsHooks.push($.jqplot.Dragable.parseOptions), $.jqplot.postDrawHooks.push($.jqplot.Dragable.postPlotDraw), 
    $.jqplot.eventListenerHooks.push([ "jqplotMouseMove", handleMove ]), $.jqplot.eventListenerHooks.push([ "jqplotMouseDown", handleDown ]), 
    $.jqplot.eventListenerHooks.push([ "jqplotMouseUp", handleUp ]);
}(jQuery);
//# sourceMappingURL=jqplot.dragable.min.js.map