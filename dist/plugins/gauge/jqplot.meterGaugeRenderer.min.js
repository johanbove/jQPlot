!function($) {
    function getnmt(pos, interval, fact) {
        for (var temp, i = pos.length - 1; i >= 0; i--) if (temp = interval / (pos[i] * Math.pow(10, fact)), 
        4 == temp || 5 == temp) return temp - 1;
        return null;
    }
    function preInit(target, data, options) {
        options = options || {}, options.axesDefaults = options.axesDefaults || {}, options.legend = options.legend || {}, 
        options.seriesDefaults = options.seriesDefaults || {}, options.grid = options.grid || {};
        var setopts = !1;
        if (options.seriesDefaults.renderer == $.jqplot.MeterGaugeRenderer) setopts = !0; else if (options.series) for (var i = 0; i < options.series.length; i++) options.series[i].renderer == $.jqplot.MeterGaugeRenderer && (setopts = !0);
        setopts && (options.axesDefaults.renderer = $.jqplot.MeterGaugeAxisRenderer, options.legend.renderer = $.jqplot.MeterGaugeLegendRenderer, 
        options.legend.preDraw = !0, options.grid.background = options.grid.background || "white", 
        options.grid.drawGridlines = !1, options.grid.borderWidth = null != options.grid.borderWidth ? options.grid.borderWidth : 0, 
        options.grid.shadow = null != options.grid.shadow ? options.grid.shadow : !1);
    }
    function postParseOptions(options) {}
    $.jqplot.MeterGaugeRenderer = function() {
        $.jqplot.LineRenderer.call(this);
    }, $.jqplot.MeterGaugeRenderer.prototype = new $.jqplot.LineRenderer(), $.jqplot.MeterGaugeRenderer.prototype.constructor = $.jqplot.MeterGaugeRenderer, 
    $.jqplot.MeterGaugeRenderer.prototype.init = function(options) {
        if (this.diameter = null, this.padding = null, this.showOuterRing = !0, this.shadowOffset = 2, 
        this.shadowAlpha = .07, this.shadowDepth = 4, this.background = "#efefef", this.ringColor = "#BBC6D0", 
        this.needleColor = "#C3D3E5", this.showHub = !0, this.hubColor = this.ringColor, 
        this.tickColor = "#989898", this.ringWidth = null, this.min, this.max, this.ticks = [], 
        this.showTicks = !0, this.showTickLabels = !0, this.label = null, this.labelHeightAdjust = 0, 
        this.labelPosition = "inside", this.intervals = [], this.intervalColors = [ "#4bb2c5", "#EAA228", "#c5b47f", "#579575", "#839557", "#958c12", "#953579", "#4b5de4", "#d8b83f", "#ff5800", "#0085cc", "#c747a3", "#cddf54", "#FBD178", "#26B4E3", "#bd70c7" ], 
        this.intervalInnerRadius = null, this.intervalOuterRadius = null, this.tickRenderer = $.jqplot.MeterGaugeTickRenderer, 
        this.tickPositions = [ 1, 2, 2.5, 5, 10 ], this.tickSpacing = 30, this.numberMinorTicks = null, 
        this.hubRadius = null, this.tickPadding = null, this.needleThickness = null, this.needlePad = 6, 
        this.pegNeedle = !0, this._type = "meterGauge", $.extend(!0, this, options), this.type = null, 
        this.numberTicks = null, this.tickInterval = null, this.span = 180, "circular" == this.type ? this.semiCircular = !1 : "circular" != this.type ? this.semiCircular = !0 : this.semiCircular = this.span <= 180 ? !0 : !1, 
        this._tickPoints = [], this._labelElem = null, this.startAngle = (90 + (360 - this.span) / 2) * Math.PI / 180, 
        this.endAngle = (90 - (360 - this.span) / 2) * Math.PI / 180, this.setmin = !(null != this.min), 
        this.setmax = !(null != this.max), this.intervals.length) if (null == this.intervals[0].length || 1 == this.intervals.length) for (var i = 0; i < this.intervals.length; i++) this.intervals[i] = [ this.intervals[i], this.intervals[i], this.intervalColors[i] ]; else if (2 == this.intervals[0].length) for (i = 0; i < this.intervals.length; i++) this.intervals[i] = [ this.intervals[i][0], this.intervals[i][1], this.intervalColors[i] ];
        if (this.ticks.length) {
            if (null == this.ticks[0].length || 1 == this.ticks[0].length) for (var i = 0; i < this.ticks.length; i++) this.ticks[i] = [ this.ticks[i], this.ticks[i] ];
            this.min = null == this.min ? this.ticks[0][0] : this.min, this.max = null == this.max ? this.ticks[this.ticks.length - 1][0] : this.max, 
            this.setmin = !1, this.setmax = !1, this.numberTicks = this.ticks.length, this.tickInterval = this.ticks[1][0] - this.ticks[0][0], 
            this.tickFactor = Math.floor(parseFloat((Math.log(this.tickInterval) / Math.log(10)).toFixed(11))), 
            this.numberMinorTicks = getnmt(this.tickPositions, this.tickInterval, this.tickFactor), 
            this.numberMinorTicks || (this.numberMinorTicks = getnmt(this.tickPositions, this.tickInterval, this.tickFactor - 1)), 
            this.numberMinorTicks || (this.numberMinorTicks = 1);
        } else this.intervals.length ? (this.min = null == this.min ? 0 : this.min, this.setmin = !1, 
        null == this.max ? this.intervals[this.intervals.length - 1][0] >= this.data[0][1] && (this.max = this.intervals[this.intervals.length - 1][0], 
        this.setmax = !1) : this.setmax = !1) : (this.min = null == this.min ? 0 : this.min, 
        this.setmin = !1, null == this.max ? (this.max = 1.25 * this.data[0][1], this.setmax = !0) : this.setmax = !1);
    }, $.jqplot.MeterGaugeRenderer.prototype.setGridData = function(plot) {
        for (var stack = [], td = [], i = (this.startAngle, 0); i < this.data.length; i++) stack.push(this.data[i][1]), 
        td.push([ this.data[i][0] ]), i > 0 && (stack[i] += stack[i - 1]);
        for (var fact = 2 * Math.PI / stack[stack.length - 1], i = 0; i < stack.length; i++) td[i][1] = stack[i] * fact;
        this.gridData = td;
    }, $.jqplot.MeterGaugeRenderer.prototype.makeGridData = function(data, plot) {
        for (var stack = [], td = [], i = (this.startAngle, 0); i < data.length; i++) stack.push(data[i][1]), 
        td.push([ data[i][0] ]), i > 0 && (stack[i] += stack[i - 1]);
        for (var fact = 2 * Math.PI / stack[stack.length - 1], i = 0; i < stack.length; i++) td[i][1] = stack[i] * fact;
        return td;
    }, $.jqplot.MeterGaugeRenderer.prototype.draw = function(ctx, gd, options) {
        var i, opts = void 0 != options ? options : {}, offx = 0, offy = 0, trans = 1;
        if (options.legendInfo && "inside" == options.legendInfo.placement) {
            var li = options.legendInfo;
            switch (li.location) {
              case "nw":
                offx = li.width + li.xoffset;
                break;

              case "w":
                offx = li.width + li.xoffset;
                break;

              case "sw":
                offx = li.width + li.xoffset;
                break;

              case "ne":
                offx = li.width + li.xoffset, trans = -1;
                break;

              case "e":
                offx = li.width + li.xoffset, trans = -1;
                break;

              case "se":
                offx = li.width + li.xoffset, trans = -1;
                break;

              case "n":
                offy = li.height + li.yoffset;
                break;

              case "s":
                offy = li.height + li.yoffset, trans = -1;
            }
        }
        this.label && (this._labelElem = $('<div class="jqplot-meterGauge-label" style="position:absolute;">' + this.label + "</div>"), 
        this.canvas._elem.after(this._labelElem));
        var cw = (void 0 != opts.shadow ? opts.shadow : this.shadow, void 0 != opts.showLine ? opts.showLine : this.showLine, 
        void 0 != opts.fill ? opts.fill : this.fill, ctx.canvas.width), ch = ctx.canvas.height;
        null == this.padding && (this.padding = Math.round(Math.min(cw, ch) / 30));
        var w = cw - offx - 2 * this.padding, h = ch - offy - 2 * this.padding;
        "bottom" == this.labelPosition && this.label && (h -= this._labelElem.outerHeight(!0));
        var mindim = Math.min(w, h), d = mindim;
        if (this.diameter || (this.semiCircular ? (w >= 2 * h ? (this.ringWidth || (this.ringWidth = 2 * h / 35), 
        this.needleThickness = this.needleThickness || 2 + Math.pow(this.ringWidth, .8), 
        this.innerPad = this.ringWidth / 2 + this.needleThickness / 2 + this.needlePad, 
        this.diameter = 2 * (h - 2 * this.innerPad)) : (this.ringWidth || (this.ringWidth = w / 35), 
        this.needleThickness = this.needleThickness || 2 + Math.pow(this.ringWidth, .8), 
        this.innerPad = this.ringWidth / 2 + this.needleThickness / 2 + this.needlePad, 
        this.diameter = w - 2 * this.innerPad - this.ringWidth - this.padding), this._center = [ (cw - trans * offx) / 2 + trans * offx, ch + trans * offy - this.padding - this.ringWidth - this.innerPad ]) : (this.ringWidth || (this.ringWidth = d / 35), 
        this.needleThickness = this.needleThickness || 2 + Math.pow(this.ringWidth, .8), 
        this.innerPad = 0, this.diameter = d - this.ringWidth, this._center = [ (cw - trans * offx) / 2 + trans * offx, (ch - trans * offy) / 2 + trans * offy ]), 
        this._labelElem && "bottom" == this.labelPosition && (this._center[1] -= this._labelElem.outerHeight(!0))), 
        this._radius = this.diameter / 2, this.tickSpacing = 6e3 / this.diameter, this.hubRadius || (this.hubRadius = this.diameter / 18), 
        this.shadowOffset = .5 + this.ringWidth / 9, this.shadowWidth = 1 * this.ringWidth, 
        this.tickPadding = 3 + Math.pow(this.diameter / 20, .7), this.tickOuterRadius = this._radius - this.ringWidth / 2 - this.tickPadding, 
        this.tickLength = this.showTicks ? this._radius / 13 : 0, 0 == this.ticks.length) {
            var max = this.max, min = this.min, setmax = this.setmax, setmin = this.setmin, ti = (max - min) * this.tickSpacing / this.span, tf = Math.floor(parseFloat((Math.log(ti) / Math.log(10)).toFixed(11))), tp = ti / Math.pow(10, tf);
            tp = tp > 2 && 2.5 >= tp ? 2.5 : Math.ceil(tp);
            var tpindex, nt, t = this.tickPositions;
            for (i = 0; i < t.length; i++) (tp == t[i] || i && t[i - 1] < tp && tp < t[i]) && (ti = t[i] * Math.pow(10, tf), 
            tpindex = i);
            for (i = 0; i < t.length; i++) (tp == t[i] || i && t[i - 1] < tp && tp < t[i]) && (ti = t[i] * Math.pow(10, tf), 
            nt = Math.ceil((max - min) / ti));
            if (setmax && setmin) {
                var tmin = min > 0 ? min - min % ti : min - min % ti - ti;
                if (!this.forceZero) {
                    var diff = Math.min(min - tmin, .8 * ti), ntp = Math.floor(diff / t[tpindex]);
                    ntp > 1 && (tmin += t[tpindex] * (ntp - 1), parseInt(tmin, 10) != tmin && parseInt(tmin - t[tpindex], 10) == tmin - t[tpindex] && (tmin -= t[tpindex]));
                }
                min == tmin ? min -= ti : min - tmin > .23 * ti ? min = tmin : (min = tmin - ti, 
                nt += 1), nt += 1;
                var tmax = min + (nt - 1) * ti;
                max >= tmax && (tmax += ti, nt += 1), .23 * ti > tmax - max && (tmax += ti, nt += 1), 
                this.max = max = tmax, this.min = min, this.tickInterval = ti, this.numberTicks = nt;
                var it;
                for (i = 0; nt > i; i++) it = parseFloat((min + i * ti).toFixed(11)), this.ticks.push([ it, it ]);
                this.max = this.ticks[nt - 1][1], this.tickFactor = tf, this.numberMinorTicks = getnmt(this.tickPositions, this.tickInterval, this.tickFactor), 
                this.numberMinorTicks || (this.numberMinorTicks = getnmt(this.tickPositions, this.tickInterval, this.tickFactor - 1));
            } else if (setmax) {
                var tmax = min + (nt - 1) * ti;
                max >= tmax ? (max = tmax + ti, nt += 1) : max = tmax, this.tickInterval = this.tickInterval || ti, 
                this.numberTicks = this.numberTicks || nt;
                var it;
                for (i = 0; i < this.numberTicks; i++) it = parseFloat((min + i * this.tickInterval).toFixed(11)), 
                this.ticks.push([ it, it ]);
                this.max = this.ticks[this.numberTicks - 1][1], this.tickFactor = tf, this.numberMinorTicks = getnmt(this.tickPositions, this.tickInterval, this.tickFactor), 
                this.numberMinorTicks || (this.numberMinorTicks = getnmt(this.tickPositions, this.tickInterval, this.tickFactor - 1));
            }
            if (!setmax && !setmin) {
                var range = this.max - this.min;
                tf = Math.floor(parseFloat((Math.log(range) / Math.log(10)).toFixed(11))) - 1;
                var res, sigRange, nticks = [ 5, 6, 4, 7, 3, 8, 9, 10, 2 ], nonSigDigits = 0;
                if (range > 1) {
                    var rstr = String(range);
                    if (-1 == rstr.search(/\./)) {
                        var pos = rstr.search(/0+$/);
                        nonSigDigits = pos > 0 ? rstr.length - pos - 1 : 0;
                    }
                }
                for (sigRange = range / Math.pow(10, nonSigDigits), i = 0; i < nticks.length; i++) if (res = sigRange / (nticks[i] - 1), 
                res == parseInt(res, 10)) {
                    this.numberTicks = nticks[i], this.tickInterval = range / (this.numberTicks - 1), 
                    this.tickFactor = tf + 1;
                    break;
                }
                var it;
                for (i = 0; i < this.numberTicks; i++) it = parseFloat((this.min + i * this.tickInterval).toFixed(11)), 
                this.ticks.push([ it, it ]);
                if (this.numberMinorTicks = getnmt(this.tickPositions, this.tickInterval, this.tickFactor), 
                this.numberMinorTicks || (this.numberMinorTicks = getnmt(this.tickPositions, this.tickInterval, this.tickFactor - 1)), 
                !this.numberMinorTicks) {
                    this.numberMinorTicks = 1;
                    var nums = [ 4, 5, 3, 6, 2 ];
                    for (i = 0; 5 > i; i++) {
                        var temp = this.tickInterval / nums[i];
                        if (temp == parseInt(temp, 10)) {
                            this.numberMinorTicks = nums[i] - 1;
                            break;
                        }
                    }
                }
            }
        }
        var r = this._radius, sa = this.startAngle, ea = this.endAngle;
        Math.PI, Math.PI / 2;
        if (this.semiCircular) {
            var overAngle = Math.atan(this.innerPad / r), outersa = this.outerStartAngle = sa - overAngle, outerea = this.outerEndAngle = ea + overAngle, hubsa = this.hubStartAngle = sa - Math.atan(this.innerPad / this.hubRadius * 2), hubea = this.hubEndAngle = ea + Math.atan(this.innerPad / this.hubRadius * 2);
            ctx.save(), ctx.translate(this._center[0], this._center[1]), ctx.lineJoin = "round", 
            ctx.lineCap = "round", ctx.save(), ctx.beginPath(), ctx.fillStyle = this.background, 
            ctx.arc(0, 0, r, outersa, outerea, !1), ctx.closePath(), ctx.fill(), ctx.restore();
            var shadowColor = "rgba(0,0,0," + this.shadowAlpha + ")";
            if (this.showOuterRing) {
                ctx.save();
                for (var i = 0; i < this.shadowDepth; i++) ctx.translate(this.shadowOffset * Math.cos(this.shadowAngle / 180 * Math.PI), this.shadowOffset * Math.sin(this.shadowAngle / 180 * Math.PI)), 
                ctx.beginPath(), ctx.strokeStyle = shadowColor, ctx.lineWidth = this.shadowWidth, 
                ctx.arc(0, 0, r, outersa, outerea, !1), ctx.closePath(), ctx.stroke();
                ctx.restore();
            }
            if (this.showHub) {
                ctx.save();
                for (var tempd = parseInt((this.shadowDepth + 1) / 2, 10), i = 0; tempd > i; i++) ctx.translate(this.shadowOffset * Math.cos(this.shadowAngle / 180 * Math.PI), this.shadowOffset * Math.sin(this.shadowAngle / 180 * Math.PI)), 
                ctx.beginPath(), ctx.fillStyle = shadowColor, ctx.arc(0, 0, this.hubRadius, hubsa, hubea, !1), 
                ctx.closePath(), ctx.fill();
                ctx.restore();
            }
            if (this.showOuterRing && (ctx.save(), ctx.beginPath(), ctx.strokeStyle = this.ringColor, 
            ctx.lineWidth = this.ringWidth, ctx.arc(0, 0, r, outersa, outerea, !1), ctx.closePath(), 
            ctx.stroke(), ctx.restore()), this.showHub && (ctx.save(), ctx.beginPath(), ctx.fillStyle = this.hubColor, 
            ctx.arc(0, 0, this.hubRadius, hubsa, hubea, !1), ctx.closePath(), ctx.fill(), ctx.restore()), 
            this.showTicks) {
                ctx.save();
                var orad = this.tickOuterRadius, tl = this.tickLength, mtl = tl / 2, nmt = this.numberMinorTicks, ts = this.span * Math.PI / 180 / (this.ticks.length - 1), mts = ts / (nmt + 1);
                for (i = 0; i < this.ticks.length; i++) {
                    ctx.beginPath(), ctx.lineWidth = 1.5 + this.diameter / 360, ctx.strokeStyle = this.ringColor;
                    if (ctx.moveTo(-orad * Math.cos(ts * i + sa), orad * Math.sin(ts * i + sa)), ctx.lineTo(-(orad - tl) * Math.cos(ts * i + sa), (orad - tl) * Math.sin(ts * i + sa)), 
                    this._tickPoints.push([ (orad - tl) * Math.cos(ts * i + sa) + this._center[0] + this.canvas._offsets.left, (orad - tl) * Math.sin(ts * i + sa) + this._center[1] + this.canvas._offsets.top, ts * i + sa ]), 
                    ctx.stroke(), ctx.lineWidth = 1 + this.diameter / 440, i < this.ticks.length - 1) for (var j = 1; nmt >= j; j++) ctx.beginPath(), 
                    ctx.moveTo(-orad * Math.cos(ts * i + mts * j + sa), orad * Math.sin(ts * i + mts * j + sa)), 
                    ctx.lineTo(-(orad - mtl) * Math.cos(ts * i + mts * j + sa), (orad - mtl) * Math.sin(ts * i + mts * j + sa)), 
                    ctx.stroke();
                }
                ctx.restore();
            }
            if (this.showTickLabels) {
                var elem, l, t, ew, eh, dim, maxdim = 0, tp = this.tickPadding * (1 - 1 / (this.diameter / 80 + 1));
                for (i = 0; i < this.ticks.length; i++) elem = $('<div class="jqplot-meterGauge-tick" style="position:absolute;">' + this.ticks[i][1] + "</div>"), 
                this.canvas._elem.after(elem), ew = elem.outerWidth(!0), eh = elem.outerHeight(!0), 
                l = this._tickPoints[i][0] - ew * (this._tickPoints[i][2] - Math.PI) / Math.PI - tp * Math.cos(this._tickPoints[i][2]), 
                t = this._tickPoints[i][1] - eh / 2 + eh / 2 * Math.pow(Math.abs(Math.sin(this._tickPoints[i][2])), .5) + tp / 3 * Math.pow(Math.abs(Math.sin(this._tickPoints[i][2])), .5), 
                elem.css({
                    left: l,
                    top: t,
                    color: this.tickColor
                }), dim = ew * Math.cos(this._tickPoints[i][2]) + eh * Math.sin(Math.PI / 2 + this._tickPoints[i][2] / 2), 
                maxdim = dim > maxdim ? dim : maxdim;
            }
            if (this.label && "inside" == this.labelPosition) {
                var l = this._center[0] + this.canvas._offsets.left, tp = this.tickPadding * (1 - 1 / (this.diameter / 80 + 1)), t = .5 * (this._center[1] + this.canvas._offsets.top - this.hubRadius) + .5 * (this._center[1] + this.canvas._offsets.top - this.tickOuterRadius + this.tickLength + tp) + this.labelHeightAdjust;
                l -= this._labelElem.outerWidth(!0) / 2, t -= this._labelElem.outerHeight(!0) / 2, 
                this._labelElem.css({
                    left: l,
                    top: t
                });
            } else if (this.label && "bottom" == this.labelPosition) {
                var l = this._center[0] + this.canvas._offsets.left - this._labelElem.outerWidth(!0) / 2, t = this._center[1] + this.canvas._offsets.top + this.innerPad + this.ringWidth + this.padding + this.labelHeightAdjust;
                this._labelElem.css({
                    left: l,
                    top: t
                });
            }
            ctx.save();
            var inner = this.intervalInnerRadius || 1.5 * this.hubRadius;
            if (null == this.intervalOuterRadius) if (this.showTickLabels) var outer = this.tickOuterRadius - this.tickLength - this.tickPadding - this.diameter / 8; else var outer = this.tickOuterRadius - this.tickLength - this.diameter / 16; else var outer = this.intervalOuterRadius;
            var start, end, range = this.max - this.min, span = (this.intervals[this.intervals.length - 1] - this.min, 
            this.span * Math.PI / 180);
            for (i = 0; i < this.intervals.length; i++) start = 0 == i ? sa : sa + (this.intervals[i - 1][0] - this.min) * span / range, 
            0 > start && (start = 0), end = sa + (this.intervals[i][0] - this.min) * span / range, 
            0 > end && (end = 0), ctx.beginPath(), ctx.fillStyle = this.intervals[i][2], ctx.arc(0, 0, inner, start, end, !1), 
            ctx.lineTo(outer * Math.cos(end), outer * Math.sin(end)), ctx.arc(0, 0, outer, end, start, !0), 
            ctx.lineTo(inner * Math.cos(start), inner * Math.sin(start)), ctx.closePath(), ctx.fill();
            ctx.restore();
            var datapoint = this.data[0][1], dataspan = this.max - this.min;
            this.pegNeedle && (this.data[0][1] > this.max + 3 * dataspan / this.span && (datapoint = this.max + 3 * dataspan / this.span), 
            this.data[0][1] < this.min - 3 * dataspan / this.span && (datapoint = this.min - 3 * dataspan / this.span));
            var dataang = (datapoint - this.min) / dataspan * this.span * Math.PI / 180 + this.startAngle;
            ctx.save(), ctx.beginPath(), ctx.fillStyle = this.needelColor, ctx.strokeStyle = this.needelColor, 
            this.needleLength = .85 * (this.tickOuterRadius - this.tickLength), this.needleThickness = this.needleThickness < 2 ? 2 : this.needleThickness;
            for (var templ, endwidth = .4 * this.needleThickness, dl = this.needleLength / 10, dt = (this.needleThickness - endwidth) / 10, i = 0; 10 > i; i++) templ = this.needleThickness - i * dt, 
            ctx.moveTo(dl * i * Math.cos(dataang), dl * i * Math.sin(dataang)), ctx.lineWidth = templ, 
            ctx.lineTo(dl * (i + 1) * Math.cos(dataang), dl * (i + 1) * Math.sin(dataang)), 
            ctx.stroke();
            ctx.restore();
        } else this._center = [ (cw - trans * offx) / 2 + trans * offx, (ch - trans * offy) / 2 + trans * offy ];
    }, $.jqplot.MeterGaugeAxisRenderer = function() {
        $.jqplot.LinearAxisRenderer.call(this);
    }, $.jqplot.MeterGaugeAxisRenderer.prototype = new $.jqplot.LinearAxisRenderer(), 
    $.jqplot.MeterGaugeAxisRenderer.prototype.constructor = $.jqplot.MeterGaugeAxisRenderer, 
    $.jqplot.MeterGaugeAxisRenderer.prototype.init = function(options) {
        this.tickRenderer = $.jqplot.MeterGaugeTickRenderer, $.extend(!0, this, options), 
        this._dataBounds = {
            min: 0,
            max: 100
        }, this.min = 0, this.max = 100, this.showTicks = !1, this.ticks = [], this.showMark = !1, 
        this.show = !1;
    }, $.jqplot.MeterGaugeLegendRenderer = function() {
        $.jqplot.TableLegendRenderer.call(this);
    }, $.jqplot.MeterGaugeLegendRenderer.prototype = new $.jqplot.TableLegendRenderer(), 
    $.jqplot.MeterGaugeLegendRenderer.prototype.constructor = $.jqplot.MeterGaugeLegendRenderer, 
    $.jqplot.MeterGaugeLegendRenderer.prototype.init = function(options) {
        this.numberRows = null, this.numberColumns = null, $.extend(!0, this, options);
    }, $.jqplot.MeterGaugeLegendRenderer.prototype.draw = function() {
        if (this.show) {
            var series = this._series, ss = "position:absolute;";
            ss += this.background ? "background:" + this.background + ";" : "", ss += this.border ? "border:" + this.border + ";" : "", 
            ss += this.fontSize ? "font-size:" + this.fontSize + ";" : "", ss += this.fontFamily ? "font-family:" + this.fontFamily + ";" : "", 
            ss += this.textColor ? "color:" + this.textColor + ";" : "", ss += null != this.marginTop ? "margin-top:" + this.marginTop + ";" : "", 
            ss += null != this.marginBottom ? "margin-bottom:" + this.marginBottom + ";" : "", 
            ss += null != this.marginLeft ? "margin-left:" + this.marginLeft + ";" : "", ss += null != this.marginRight ? "margin-right:" + this.marginRight + ";" : "", 
            this._elem = $('<table class="jqplot-table-legend" style="' + ss + '"></table>');
            var nr, nc, pad = !1, reverse = !1, s = series[0];
            if (s.show) {
                var pd = s.data;
                this.numberRows ? (nr = this.numberRows, nc = this.numberColumns ? this.numberColumns : Math.ceil(pd.length / nr)) : this.numberColumns ? (nc = this.numberColumns, 
                nr = Math.ceil(pd.length / this.numberColumns)) : (nr = pd.length, nc = 1);
                var i, j, tr, td1, td2, lt, rs, color, idx = 0;
                for (i = 0; nr > i; i++) for (tr = reverse ? $('<tr class="jqplot-table-legend"></tr>').prependTo(this._elem) : $('<tr class="jqplot-table-legend"></tr>').appendTo(this._elem), 
                j = 0; nc > j; j++) idx < pd.length && (lt = this.labels[idx] || pd[idx][0].toString(), 
                color = s.color, pad = reverse ? i == nr - 1 ? !1 : !0 : i > 0 ? !0 : !1, rs = pad ? this.rowSpacing : "0", 
                td1 = $('<td class="jqplot-table-legend" style="text-align:center;padding-top:' + rs + ';"><div><div class="jqplot-table-legend-swatch" style="border-color:' + color + ';"></div></div></td>'), 
                td2 = $('<td class="jqplot-table-legend" style="padding-top:' + rs + ';"></td>'), 
                this.escapeHtml ? td2.text(lt) : td2.html(lt), reverse ? (td2.prependTo(tr), td1.prependTo(tr)) : (td1.appendTo(tr), 
                td2.appendTo(tr)), pad = !0), idx++;
            }
        }
        return this._elem;
    }, $.jqplot.preInitHooks.push(preInit), $.jqplot.postParseOptionsHooks.push(postParseOptions), 
    $.jqplot.MeterGaugeTickRenderer = function() {
        $.jqplot.AxisTickRenderer.call(this);
    }, $.jqplot.MeterGaugeTickRenderer.prototype = new $.jqplot.AxisTickRenderer(), 
    $.jqplot.MeterGaugeTickRenderer.prototype.constructor = $.jqplot.MeterGaugeTickRenderer;
}(jQuery);
//# sourceMappingURL=jqplot.meterGaugeRenderer.min.js.map