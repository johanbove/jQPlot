!function($) {
    function preInit(target, data, options) {
        options = options || {}, options.axesDefaults = options.axesDefaults || {}, options.legend = options.legend || {}, 
        options.seriesDefaults = options.seriesDefaults || {};
        var setopts = !1;
        if (options.seriesDefaults.renderer == $.jqplot.MekkoRenderer) setopts = !0; else if (options.series) for (var i = 0; i < options.series.length; i++) options.series[i].renderer == $.jqplot.MekkoRenderer && (setopts = !0);
        setopts && (options.axesDefaults.renderer = $.jqplot.MekkoAxisRenderer, options.legend.renderer = $.jqplot.MekkoLegendRenderer, 
        options.legend.preDraw = !0);
    }
    $.jqplot.MekkoRenderer = function() {
        this.shapeRenderer = new $.jqplot.ShapeRenderer(), this.borderColor = null, this.showBorders = !0;
    }, $.jqplot.MekkoRenderer.prototype.init = function(options, plot) {
        this.fill = !1, this.fillRect = !0, this.strokeRect = !0, this.shadow = !1, this._xwidth = 0, 
        this._xstart = 0, $.extend(!0, this.renderer, options);
        var opts = {
            lineJoin: "miter",
            lineCap: "butt",
            isarc: !1,
            fillRect: this.fillRect,
            strokeRect: this.strokeRect
        };
        this.renderer.shapeRenderer.init(opts), plot.axes.x2axis._series.push(this), this._type = "mekko";
    }, $.jqplot.MekkoRenderer.prototype.setGridData = function(plot) {
        var xp = this._xaxis.series_u2p, data = (this._yaxis.series_u2p, this._plotData);
        this.gridData = [], this._xwidth = xp(this._sumy) - xp(0), this.index > 0 && (this._xstart = plot.series[this.index - 1]._xstart + plot.series[this.index - 1]._xwidth);
        for (var cury, curheight, totheight = this.canvas.getHeight(), sumy = 0, i = 0; i < data.length; i++) null != data[i] && (sumy += data[i][1], 
        cury = totheight - sumy / this._sumy * totheight, curheight = data[i][1] / this._sumy * totheight, 
        this.gridData.push([ this._xstart, cury, this._xwidth, curheight ]));
    }, $.jqplot.MekkoRenderer.prototype.makeGridData = function(data, plot) {
        for (var cury, curheight, totheight = (this._xaxis.series_u2p, this.canvas.getHeight()), sumy = 0, gd = [], i = 0; i < data.length; i++) null != data[i] && (sumy += data[i][1], 
        cury = totheight - sumy / this._sumy * totheight, curheight = data[i][1] / this._sumy * totheight, 
        gd.push([ this._xstart, cury, this._xwidth, curheight ]));
        return gd;
    }, $.jqplot.MekkoRenderer.prototype.draw = function(ctx, gd, options) {
        var i, opts = void 0 != options ? options : {}, showLine = void 0 != opts.showLine ? opts.showLine : this.showLine, colorGenerator = new $.jqplot.ColorGenerator(this.seriesColors);
        if (ctx.save(), gd.length && showLine) for (i = 0; i < gd.length; i++) opts.fillStyle = colorGenerator.next(), 
        this.renderer.showBorders ? opts.strokeStyle = this.renderer.borderColor : opts.strokeStyle = opts.fillStyle, 
        this.renderer.shapeRenderer.draw(ctx, gd[i], opts);
        ctx.restore();
    }, $.jqplot.MekkoRenderer.prototype.drawShadow = function(ctx, gd, options) {}, 
    $.jqplot.MekkoLegendRenderer = function() {}, $.jqplot.MekkoLegendRenderer.prototype.init = function(options) {
        this.numberRows = null, this.numberColumns = null, this.placement = "outside", $.extend(!0, this, options);
    }, $.jqplot.MekkoLegendRenderer.prototype.draw = function() {
        if (this.show) {
            var series = this._series, ss = "position:absolute;";
            ss += this.background ? "background:" + this.background + ";" : "", ss += this.border ? "border:" + this.border + ";" : "", 
            ss += this.fontSize ? "font-size:" + this.fontSize + ";" : "", ss += this.fontFamily ? "font-family:" + this.fontFamily + ";" : "", 
            ss += this.textColor ? "color:" + this.textColor + ";" : "", this._elem = $('<table class="jqplot-table-legend" style="' + ss + '"></table>');
            var nr, nc, pad = !1, reverse = !0, s = series[0], colorGenerator = new $.jqplot.ColorGenerator(s.seriesColors);
            if (s.show) {
                var pd = s.data;
                this.numberRows ? (nr = this.numberRows, nc = this.numberColumns ? this.numberColumns : Math.ceil(pd.length / nr)) : this.numberColumns ? (nc = this.numberColumns, 
                nr = Math.ceil(pd.length / this.numberColumns)) : (nr = pd.length, nc = 1);
                var i, j, tr, td1, td2, lt, rs, color, idx = 0;
                for (i = 0; nr > i; i++) for (tr = reverse ? $('<tr class="jqplot-table-legend"></tr>').prependTo(this._elem) : $('<tr class="jqplot-table-legend"></tr>').appendTo(this._elem), 
                j = 0; nc > j; j++) idx < pd.length && (lt = this.labels[idx] || pd[idx][0].toString(), 
                color = colorGenerator.next(), pad = reverse ? i == nr - 1 ? !1 : !0 : i > 0 ? !0 : !1, 
                rs = pad ? this.rowSpacing : "0", td1 = $('<td class="jqplot-table-legend" style="text-align:center;padding-top:' + rs + ';"><div><div class="jqplot-table-legend-swatch" style="border-color:' + color + ';"></div></div></td>'), 
                td2 = $('<td class="jqplot-table-legend" style="padding-top:' + rs + ';"></td>'), 
                this.escapeHtml ? td2.text(lt) : td2.html(lt), reverse ? (td2.prependTo(tr), td1.prependTo(tr)) : (td1.appendTo(tr), 
                td2.appendTo(tr)), pad = !0), idx++;
                tr = null, td1 = null, td2 = null;
            }
        }
        return this._elem;
    }, $.jqplot.MekkoLegendRenderer.prototype.pack = function(offsets) {
        if (this.show) {
            var grid = {
                _top: offsets.top,
                _left: offsets.left,
                _right: offsets.right,
                _bottom: this._plotDimensions.height - offsets.bottom
            };
            if ("insideGrid" == this.placement) switch (this.location) {
              case "nw":
                var a = grid._left + this.xoffset, b = grid._top + this.yoffset;
                this._elem.css("left", a), this._elem.css("top", b);
                break;

              case "n":
                var a = (offsets.left + (this._plotDimensions.width - offsets.right)) / 2 - this.getWidth() / 2, b = grid._top + this.yoffset;
                this._elem.css("left", a), this._elem.css("top", b);
                break;

              case "ne":
                var a = offsets.right + this.xoffset, b = grid._top + this.yoffset;
                this._elem.css({
                    right: a,
                    top: b
                });
                break;

              case "e":
                var a = offsets.right + this.xoffset, b = (offsets.top + (this._plotDimensions.height - offsets.bottom)) / 2 - this.getHeight() / 2;
                this._elem.css({
                    right: a,
                    top: b
                });
                break;

              case "se":
                var a = offsets.right + this.xoffset, b = offsets.bottom + this.yoffset;
                this._elem.css({
                    right: a,
                    bottom: b
                });
                break;

              case "s":
                var a = (offsets.left + (this._plotDimensions.width - offsets.right)) / 2 - this.getWidth() / 2, b = offsets.bottom + this.yoffset;
                this._elem.css({
                    left: a,
                    bottom: b
                });
                break;

              case "sw":
                var a = grid._left + this.xoffset, b = offsets.bottom + this.yoffset;
                this._elem.css({
                    left: a,
                    bottom: b
                });
                break;

              case "w":
                var a = grid._left + this.xoffset, b = (offsets.top + (this._plotDimensions.height - offsets.bottom)) / 2 - this.getHeight() / 2;
                this._elem.css({
                    left: a,
                    top: b
                });
                break;

              default:
                var a = grid._right - this.xoffset, b = grid._bottom + this.yoffset;
                this._elem.css({
                    right: a,
                    bottom: b
                });
            } else switch (this.location) {
              case "nw":
                var a = this._plotDimensions.width - grid._left + this.xoffset, b = grid._top + this.yoffset;
                this._elem.css("right", a), this._elem.css("top", b);
                break;

              case "n":
                var a = (offsets.left + (this._plotDimensions.width - offsets.right)) / 2 - this.getWidth() / 2, b = this._plotDimensions.height - grid._top + this.yoffset;
                this._elem.css("left", a), this._elem.css("bottom", b);
                break;

              case "ne":
                var a = this._plotDimensions.width - offsets.right + this.xoffset, b = grid._top + this.yoffset;
                this._elem.css({
                    left: a,
                    top: b
                });
                break;

              case "e":
                var a = this._plotDimensions.width - offsets.right + this.xoffset, b = (offsets.top + (this._plotDimensions.height - offsets.bottom)) / 2 - this.getHeight() / 2;
                this._elem.css({
                    left: a,
                    top: b
                });
                break;

              case "se":
                var a = this._plotDimensions.width - offsets.right + this.xoffset, b = offsets.bottom + this.yoffset;
                this._elem.css({
                    left: a,
                    bottom: b
                });
                break;

              case "s":
                var a = (offsets.left + (this._plotDimensions.width - offsets.right)) / 2 - this.getWidth() / 2, b = this._plotDimensions.height - offsets.bottom + this.yoffset;
                this._elem.css({
                    left: a,
                    top: b
                });
                break;

              case "sw":
                var a = this._plotDimensions.width - grid._left + this.xoffset, b = offsets.bottom + this.yoffset;
                this._elem.css({
                    right: a,
                    bottom: b
                });
                break;

              case "w":
                var a = this._plotDimensions.width - grid._left + this.xoffset, b = (offsets.top + (this._plotDimensions.height - offsets.bottom)) / 2 - this.getHeight() / 2;
                this._elem.css({
                    right: a,
                    top: b
                });
                break;

              default:
                var a = grid._right - this.xoffset, b = grid._bottom + this.yoffset;
                this._elem.css({
                    right: a,
                    bottom: b
                });
            }
        }
    }, $.jqplot.preInitHooks.push(preInit);
}(jQuery);
//# sourceMappingURL=jqplot.mekkoRenderer.min.js.map