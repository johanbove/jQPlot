!function($) {
    "use strict";
    function LineBase() {
        this.uid = null, this.type = null, this.gridStart = null, this.gridStop = null, 
        this.tooltipWidthFactor = 0, this.options = {
            name: null,
            show: !0,
            lineWidth: 2,
            lineCap: "round",
            color: "#666666",
            shadow: !0,
            shadowAngle: 45,
            shadowOffset: 1,
            shadowDepth: 3,
            shadowAlpha: "0.07",
            xaxis: "xaxis",
            yaxis: "yaxis",
            showTooltip: !1,
            showTooltipPrecision: .6,
            tooltipLocation: "nw",
            fadeTooltip: !0,
            tooltipFadeSpeed: "fast",
            tooltipOffset: 4,
            tooltipFormatString: "%d, %d",
            xformat: null,
            yformat: null
        };
    }
    function WorkItem(options) {
        LineBase.call(this), this.type = "workitem";
        var opts = {
            xmin: null,
            xmax: null,
            ymin: null,
            ymax: null
        };
        $.extend(!0, this.options, opts, options);
    }
    function Rectangle(options) {
        LineBase.call(this), this.type = "rectangle";
        var opts = {
            xmin: null,
            xmax: null,
            xOffset: "6px",
            xminOffset: null,
            xmaxOffset: null,
            ymin: null,
            ymax: null,
            yOffset: "6px",
            yminOffset: null,
            ymaxOffset: null
        };
        $.extend(!0, this.options, opts, options), this.options.showTooltipPrecision < .01 && (this.options.showTooltipPrecision = .01);
    }
    function Line(options) {
        LineBase.call(this), this.type = "line";
        var opts = {
            start: [],
            stop: []
        };
        $.extend(!0, this.options, opts, options), this.options.showTooltipPrecision < .01 && (this.options.showTooltipPrecision = .01);
    }
    function HorizontalLine(options) {
        LineBase.call(this), this.type = "horizontalLine";
        var opts = {
            y: null,
            xmin: null,
            xmax: null,
            xOffset: "6px",
            xminOffset: null,
            xmaxOffset: null
        };
        $.extend(!0, this.options, opts, options), this.options.showTooltipPrecision < .01 && (this.options.showTooltipPrecision = .01);
    }
    function DashedHorizontalLine(options) {
        LineBase.call(this), this.type = "dashedHorizontalLine";
        var opts = {
            y: null,
            xmin: null,
            xmax: null,
            xOffset: "6px",
            xminOffset: null,
            xmaxOffset: null,
            dashPattern: [ 8, 8 ]
        };
        $.extend(!0, this.options, opts, options), this.options.showTooltipPrecision < .01 && (this.options.showTooltipPrecision = .01);
    }
    function VerticalLine(options) {
        LineBase.call(this), this.type = "verticalLine";
        var opts = {
            x: null,
            ymin: null,
            ymax: null,
            yOffset: "6px",
            yminOffset: null,
            ymaxOffset: null
        };
        $.extend(!0, this.options, opts, options), this.options.showTooltipPrecision < .01 && (this.options.showTooltipPrecision = .01);
    }
    function DashedVerticalLine(options) {
        LineBase.call(this), this.type = "dashedVerticalLine", this.start = null, this.stop = null;
        var opts = {
            x: null,
            ymin: null,
            ymax: null,
            yOffset: "6px",
            yminOffset: null,
            ymaxOffset: null,
            dashPattern: [ 8, 8 ]
        };
        $.extend(!0, this.options, opts, options), this.options.showTooltipPrecision < .01 && (this.options.showTooltipPrecision = .01);
    }
    function showTooltip(plot, obj, gridpos, datapos) {
        var x, y, co = plot.plugins.canvasOverlay, elem = co._tooltipElem, opts = obj.options;
        switch (elem.html($.jqplot.sprintf(opts.tooltipFormatString, datapos[0], datapos[1])), 
        opts.tooltipLocation) {
          case "nw":
            x = gridpos[0] - plot._gridPadding.left - 1.5 * elem.outerWidth(!0) - opts.tooltipOffset, 
            y = gridpos[1] + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(!0);
            break;

          case "n":
            x = gridpos[0] - elem.outerWidth(!0) - opts.tooltipOffset, y = gridpos[1] + plot._gridPadding.top - opts.tooltipOffset - 1.5 * elem.outerHeight(!0);
            break;

          case "ne":
            x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(!0) / 1.5 - opts.tooltipOffset, 
            y = gridpos[1] + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(!0);
            break;

          case "e":
            x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(!0) / 1.5 - opts.tooltipOffset, 
            y = gridpos[1] + plot._gridPadding.top - elem.outerHeight(!0) / 2;
            break;

          case "se":
            x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(!0) / 1.5 - opts.tooltipOffset, 
            y = gridpos[1] + plot._gridPadding.top + opts.tooltipOffset + .5 * elem.outerHeight(!0);
            break;

          case "s":
            x = gridpos[0] - elem.outerWidth(!0) - opts.tooltipOffset, y = gridpos[1] + plot._gridPadding.top + opts.tooltipOffset + .5 * elem.outerHeight(!0);
            break;

          case "sw":
            x = gridpos[0] - plot._gridPadding.left - 1.5 * elem.outerWidth(!0) - opts.tooltipOffset, 
            y = gridpos[1] + plot._gridPadding.top + opts.tooltipOffset + .5 * elem.outerHeight(!0);
            break;

          case "w":
            x = gridpos[0] - plot._gridPadding.left - 1.5 * elem.outerWidth(!0) - opts.tooltipOffset, 
            y = gridpos[1] + plot._gridPadding.top - elem.outerHeight(!0) / 2;
            break;

          default:
            x = gridpos[0] + plot._gridPadding.left - elem.outerWidth(!0) - opts.tooltipOffset, 
            y = gridpos[1] + plot._gridPadding.top - opts.tooltipOffset - elem.outerHeight(!0);
        }
        elem.css({
            left: x,
            top: y,
            zIndex: 1
        }), opts.fadeTooltip ? elem.stop(!0, !0).fadeIn(opts.tooltipFadeSpeed) : elem.show(), 
        elem = null;
    }
    function isNearLine(point, lstart, lstop, width) {
        var rx, ry, px, py, qx, qy, l, eps, res, ret;
        return rx = point[0], ry = point[1], px = Math.round(lstop[0]), py = Math.round(lstop[1]), 
        qx = Math.round(lstart[0]), qy = Math.round(lstart[1]), l = Math.sqrt(Math.pow(px - qx, 2) + Math.pow(py - qy, 2)), 
        eps = width * l, res = Math.abs((qx - px) * (ry - py) - (qy - py) * (rx - px)), 
        ret = eps > res ? !0 : !1;
    }
    function isNearRectangle(point, lstart, lstop, width) {
        var rx, ry, px, py, qx, qy, temp, ret;
        return rx = point[0], ry = point[1], px = Math.round(lstop[0]), py = Math.round(lstop[1]), 
        qx = Math.round(lstart[0]), qy = Math.round(lstart[1]), px > qx && (temp = px, px = qx, 
        qx = temp), py > qy && (temp = py, py = qy, qy = temp), ret = rx >= px && qx >= rx && ry >= py && qy >= ry;
    }
    function handleMove(ev, gridpos, datapos, neighbor, plot) {
        var obj, elem, i, n, co = plot.plugins.canvasOverlay, objs = co.objects, l = objs.length, haveHighlight = !1;
        for (i = 0; l > i; i++) if (obj = objs[i], obj.options.showTooltip) {
            if (n = "rectangle" === obj.type ? isNearRectangle([ gridpos.x, gridpos.y ], obj.gridStart, obj.gridStop, obj.tooltipWidthFactor) : isNearLine([ gridpos.x, gridpos.y ], obj.gridStart, obj.gridStop, obj.tooltipWidthFactor), 
            datapos = [ plot.axes[obj.options.xaxis].series_p2u(gridpos.x), plot.axes[obj.options.yaxis].series_p2u(gridpos.y) ], 
            n && null === co.highlightObjectIndex) {
                switch (obj.type) {
                  case "line":
                    showTooltip(plot, obj, [ gridpos.x, gridpos.y ], datapos);
                    break;

                  case "horizontalLine":
                  case "dashedHorizontalLine":
                    showTooltip(plot, obj, [ gridpos.x, obj.gridStart[1] ], [ datapos[0], obj.options.y ]);
                    break;

                  case "verticalLine":
                  case "dashedVerticalLine":
                    showTooltip(plot, obj, [ obj.gridStart[0], gridpos.y ], [ obj.options.x, datapos[1] ]);
                    break;

                  case "rectangle":
                    showTooltip(plot, obj, [ ev.pageX, gridpos.y ], [ obj.options.x, datapos[1] ]);
                }
                co.highlightObjectIndex = i, haveHighlight = !0;
                break;
            }
            if (n && co.highlightObjectIndex !== i) {
                switch (elem = co._tooltipElem, obj.fadeTooltip ? elem.fadeOut(obj.tooltipFadeSpeed) : elem.hide(), 
                obj.type) {
                  case "line":
                    showTooltip(plot, obj, [ gridpos.x, gridpos.y ], datapos);
                    break;

                  case "horizontalLine":
                  case "dashedHorizontalLine":
                    showTooltip(plot, obj, [ gridpos.x, obj.gridStart[1] ], [ datapos[0], obj.options.y ]);
                    break;

                  case "verticalLine":
                  case "dashedVerticalLine":
                    showTooltip(plot, obj, [ obj.gridStart[0], gridpos.y ], [ obj.options.x, datapos[1] ]);
                    break;

                  case "rectangle":
                    showTooltip(plot, obj, [ ev.pageX, gridpos.y ], [ obj.options.x, datapos[1] ]);
                }
                co.highlightObjectIndex = i, haveHighlight = !0;
                break;
            }
            if (n) {
                switch (obj.type) {
                  case "line":
                    showTooltip(plot, obj, [ gridpos.x, gridpos.y ], datapos);
                    break;

                  case "horizontalLine":
                  case "dashedHorizontalLine":
                    showTooltip(plot, obj, [ gridpos.x, obj.gridStart[1] ], [ datapos[0], obj.options.y ]);
                    break;

                  case "verticalLine":
                  case "dashedVerticalLine":
                    showTooltip(plot, obj, [ obj.gridStart[0], gridpos.y ], [ obj.options.x, datapos[1] ]);
                    break;

                  case "rectangle":
                    showTooltip(plot, obj, [ ev.pageX, gridpos.y ], [ obj.options.x, datapos[1] ]);
                }
                haveHighlight = !0;
                break;
            }
        }
        haveHighlight || null === co.highlightObjectIndex || (elem = co._tooltipElem, obj = co.getObject(co.highlightObjectIndex), 
        obj.fadeTooltip ? elem.fadeOut(obj.tooltipFadeSpeed) : elem.hide(), co.highlightObjectIndex = null);
    }
    var objCounter = 0;
    $.jqplot.CanvasOverlay = function(opts) {
        var objs, objslen, obj, i, element, options = opts || {};
        if (this.options = {
            bellowSeries: !1,
            show: $.jqplot.config.enablePlugins,
            deferDraw: !1
        }, this.objects = [], this.objectNames = [], this.canvas = null, this.markerRenderer = new $.jqplot.MarkerRenderer({
            style: "line"
        }), this.markerRenderer.init(), this.highlightObjectIndex = null, options.objects) for (objs = options.objects, 
        i = 0, objslen = objs.length; objslen > i; i++) {
            obj = objs[i];
            for (element in obj) if (obj.hasOwnProperty(element)) switch (element) {
              case "line":
                this.addLine(obj[element]);
                break;

              case "horizontalLine":
                this.addHorizontalLine(obj[element]);
                break;

              case "dashedHorizontalLine":
                this.addDashedHorizontalLine(obj[element]);
                break;

              case "verticalLine":
                this.addVerticalLine(obj[element]);
                break;

              case "dashedVerticalLine":
                this.addDashedVerticalLine(obj[element]);
                break;

              case "rectangle":
                this.addRectangle(obj[element]);
                break;

              case "workitem":
                this.addWorkItem(obj[element]);
            }
        }
        $.extend(!0, this.options, options);
    }, $.jqplot.CanvasOverlay.postPlotInit = function(target, data, opts) {
        var options = opts || {};
        this.plugins.canvasOverlay = new $.jqplot.CanvasOverlay(options.canvasOverlay);
    }, WorkItem.prototype = new LineBase(), WorkItem.prototype.constructor = WorkItem, 
    Rectangle.prototype = new LineBase(), Rectangle.prototype.constructor = Rectangle, 
    Line.prototype = new LineBase(), Line.prototype.constructor = Line, HorizontalLine.prototype = new LineBase(), 
    HorizontalLine.prototype.constructor = HorizontalLine, DashedHorizontalLine.prototype = new LineBase(), 
    DashedHorizontalLine.prototype.constructor = DashedHorizontalLine, VerticalLine.prototype = new LineBase(), 
    VerticalLine.prototype.constructor = VerticalLine, DashedVerticalLine.prototype = new LineBase(), 
    DashedVerticalLine.prototype.constructor = DashedVerticalLine, $.jqplot.CanvasOverlay.prototype.addLine = function(opts) {
        var obj = new Line(opts);
        obj.uid = objCounter++, this.objects.push(obj), this.objectNames.push(obj.options.name);
    }, $.jqplot.CanvasOverlay.prototype.addHorizontalLine = function(opts) {
        var obj = new HorizontalLine(opts);
        obj.uid = objCounter++, this.objects.push(obj), this.objectNames.push(obj.options.name);
    }, $.jqplot.CanvasOverlay.prototype.addDashedHorizontalLine = function(opts) {
        var obj = new DashedHorizontalLine(opts);
        obj.uid = objCounter++, this.objects.push(obj), this.objectNames.push(obj.options.name);
    }, $.jqplot.CanvasOverlay.prototype.addVerticalLine = function(opts) {
        var obj = new VerticalLine(opts);
        obj.uid = objCounter++, this.objects.push(obj), this.objectNames.push(obj.options.name);
    }, $.jqplot.CanvasOverlay.prototype.addDashedVerticalLine = function(opts) {
        var obj = new DashedVerticalLine(opts);
        obj.uid = objCounter++, this.objects.push(obj), this.objectNames.push(obj.options.name);
    }, $.jqplot.CanvasOverlay.prototype.addRectangle = function(opts) {
        var obj = new Rectangle(opts);
        obj.uid = objCounter++, this.objects.push(obj), this.objectNames.push(obj.options.name);
    }, $.jqplot.CanvasOverlay.prototype.addWorkItem = function(opts) {
        var obj = new WorkItem(opts);
        obj.uid = objCounter++, this.objects.push(obj), this.objectNames.push(obj.options.name);
    }, $.jqplot.CanvasOverlay.prototype.removeObject = function(idx) {
        var id;
        "number" === $.type(idx) ? (this.objects.splice(idx, 1), this.objectNames.splice(idx, 1)) : (id = $.inArray(idx, this.objectNames), 
        -1 !== id && (this.objects.splice(id, 1), this.objectNames.splice(id, 1)));
    }, $.jqplot.CanvasOverlay.prototype.getObject = function(idx) {
        var id;
        return "number" === $.type(idx) ? this.objects[idx] : (id = $.inArray(idx, this.objectNames), 
        -1 !== id ? this.objects[id] : void 0);
    }, $.jqplot.CanvasOverlay.prototype.get = $.jqplot.CanvasOverlay.prototype.getObject, 
    $.jqplot.CanvasOverlay.prototype.clear = function(plot) {
        this.canvas._ctx.clearRect(0, 0, this.canvas.getWidth(), this.canvas.getHeight());
    }, $.jqplot.CanvasOverlay.prototype.draw = function(plot) {
        plot.objectCounter = {};
        var obj, k, opts, canvas = this.canvas, objs = this.objects, objslen = objs.length, mr = this.markerRenderer, rendererLine = function(mr, opts, obj, plot) {
            var xstart, xstop, ystart, ystop, start, stop;
            mr.style = "line", opts.closePath = !1, obj.options.xformat && "date" === obj.options.xformat.type ? obj.options.xformat.format ? (xstart = plot.axes[obj.options.xaxis].series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.start[0], obj.options.xformat.format)).getTime()), 
            xstop = plot.axes[obj.options.xaxis].series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.stop[0], obj.options.xformat.format)).getTime())) : (xstart = plot.axes[obj.options.xaxis].series_u2p($.jsDate.createDate(obj.options.start[0])), 
            xstop = plot.axes[obj.options.xaxis].series_u2p($.jsDate.createDate(obj.options.stop[0]))) : (xstart = plot.axes[obj.options.xaxis].series_u2p(obj.options.start[0]), 
            xstop = plot.axes[obj.options.xaxis].series_u2p(obj.options.stop[0])), obj.options.yformat && "date" === obj.options.yformat.type ? "undefined" != typeof obj.options.yformat.format ? (ystart = plot.axes[obj.options.yaxis].series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.start[1], obj.options.yformat.format)).getTime()), 
            ystop = plot.axes[obj.options.yaxis].series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.stop[1], obj.options.yformat.format)).getTime())) : (ystart = plot.axes[obj.options.yaxis].series_u2p($.jsDate.createDate(obj.options.start[1])), 
            ystop = plot.axes[obj.options.yaxis].series_u2p($.jsDate.createDate(obj.options.stop[1]))) : (ystart = plot.axes[obj.options.yaxis].series_u2p(obj.options.start[1]), 
            ystop = plot.axes[obj.options.yaxis].series_u2p(obj.options.stop[1])), start = [ xstart, ystart ], 
            stop = [ xstop, ystop ], obj.gridStart = start, obj.gridStop = stop, mr.draw(start, stop, canvas._ctx, opts);
        }, rendererHorizontalLine = function(mr, opts, obj, plot) {
            var xaxis, xstart, xstop, y, xminoff, xmaxoff;
            null !== obj.options.y && (mr.style = "line", opts.closePath = !1, xaxis = plot.axes[obj.options.xaxis], 
            y = plot.axes[obj.options.yaxis].series_u2p(obj.options.y), xminoff = obj.options.xminOffset || obj.options.xOffset, 
            xmaxoff = obj.options.xmaxOffset || obj.options.xOffset, obj.options.yformat && "date" === obj.options.yformat.type && (y = obj.options.yformat.format ? plot.axes[obj.options.yaxis].series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.y, obj.options.yformat.format)).getTime()) : plot.axes[obj.options.yaxis].series_u2p($.jsDate.createDate(obj.options.y).getTime())), 
            null !== obj.options.xmin ? xstart = obj.options.xformat && "date" === obj.options.xformat.type ? obj.options.xformat.format ? xaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.xmin, obj.options.xformat.format)).getTime()) : xaxis.series_u2p($.jsDate.createDate(obj.options.xmin).getTime()) : xaxis.series_u2p(obj.options.xmin) : null !== xminoff && ("number" === $.type(xminoff) ? xstart = xaxis.series_u2p(xaxis.min + xminoff) : "string" === $.type(xminoff) && (xstart = xaxis.series_u2p(xaxis.min) + parseFloat(xminoff))), 
            null !== obj.options.xmax ? xstop = obj.options.xformat && "date" === obj.options.xformat.type ? obj.options.xformat.format ? xaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.xmax, obj.options.xformat.format)).getTime()) : xaxis.series_u2p($.jsDate.createDate(obj.options.xmax).getTime()) : xaxis.series_u2p(obj.options.xmax) : null !== xmaxoff && ("number" === $.type(xmaxoff) ? xstop = xaxis.series_u2p(xaxis.max - xmaxoff) : "string" === $.type(xmaxoff) && (xstop = xaxis.series_u2p(xaxis.max) - parseFloat(xmaxoff))), 
            null !== xstop && null !== xstart && (obj.gridStart = [ xstart, y ], obj.gridStop = [ xstop, y ], 
            mr.draw([ xstart, y ], [ xstop, y ], canvas._ctx, opts)));
        }, rendererDashedHorizontalLine = function(mr, opts, obj, plot) {
            var i, xaxis, xstart, xstop, y, xminoff, xmaxoff, numDash, b, e, j, dashPat = obj.options.dashPattern, dashPatLen = 0;
            for (i = 0; i < dashPat.length; i++) dashPatLen += dashPat[i];
            if (null !== obj.options.y && (mr.style = "line", opts.closePath = !1, xaxis = plot.axes[obj.options.xaxis], 
            y = plot.axes[obj.options.yaxis].series_u2p(obj.options.y), xminoff = obj.options.xminOffset || obj.options.xOffset, 
            xmaxoff = obj.options.xmaxOffset || obj.options.xOffset, obj.options.yformat && "date" === obj.options.yformat.type && (y = obj.options.yformat.format ? plot.axes[obj.options.yaxis].series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.y, obj.options.yformat.format)).getTime()) : plot.axes[obj.options.yaxis].series_u2p($.jsDate.createDate(obj.options.y).getTime())), 
            null !== obj.options.xmin ? xstart = obj.options.xformat && "date" === obj.options.xformat.type ? obj.options.xformat.format ? xaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.xmin, obj.options.xformat.format)).getTime()) : xaxis.series_u2p($.jsDate.createDate(obj.options.xmin).getTime()) : xaxis.series_u2p(obj.options.xmin) : null !== xminoff && ("number" === $.type(xminoff) ? xstart = xaxis.series_u2p(xaxis.min + xminoff) : "string" === $.type(xminoff) && (xstart = xaxis.series_u2p(xaxis.min) + parseFloat(xminoff))), 
            null !== obj.options.xmax ? xstop = obj.options.xformat && "date" === obj.options.xformat.type ? obj.options.xformat.format ? xaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.xmax, obj.options.xformat.format)).getTime()) : xaxis.series_u2p($.jsDate.createDate(obj.options.xmax).getTime()) : xaxis.series_u2p(obj.options.xmax) : null !== xmaxoff && ("number" === $.type(xmaxoff) ? xstop = xaxis.series_u2p(xaxis.max - xmaxoff) : "string" === $.type(xmaxoff) && (xstop = xaxis.series_u2p(xaxis.max) - parseFloat(xmaxoff))), 
            null !== xstop && null !== xstart)) for (obj.gridStart = [ xstart, y ], obj.gridStop = [ xstop, y ], 
            numDash = Math.ceil((xstop - xstart) / dashPatLen), b = xstart, i = 0; numDash > i; i++) for (j = 0; j < dashPat.length; j += 2) e = b + dashPat[j], 
            mr.draw([ b, y ], [ e, y ], canvas._ctx, opts), b += dashPat[j], j < dashPat.length - 1 && (b += dashPat[j + 1]);
        }, rendererVerticalLine = function(mr, opts, obj, plot) {
            var yaxis, ystop, ystart, x, yminoff, ymaxoff;
            null !== obj.options.x && (mr.style = "line", opts.closePath = !1, yaxis = plot.axes[obj.options.yaxis], 
            x = plot.axes[obj.options.xaxis].series_u2p(obj.options.x), yminoff = obj.options.yminOffset || obj.options.yOffset, 
            ymaxoff = obj.options.ymaxOffset || obj.options.yOffset, obj.options.xformat && "date" === obj.options.xformat.type && (x = obj.options.xformat.format ? plot.axes[obj.options.xaxis].series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.x, obj.options.xformat.format)).getTime()) : plot.axes[obj.options.xaxis].series_u2p($.jsDate.createDate(obj.options.x).getTime())), 
            null !== obj.options.ymin ? ystart = obj.options.yformat && "date" === obj.options.yformat.type ? obj.options.yformat.format ? yaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.ymin, obj.options.yformat.format)).getTime()) : yaxis.series_u2p($.jsDate.createDate(obj.options.ymin).getTime()) : yaxis.series_u2p(obj.options.ymin) : null !== yminoff && ("number" === $.type(yminoff) ? ystart = yaxis.series_u2p(yaxis.min - yminoff) : "string" === $.type(yminoff) && (ystart = yaxis.series_u2p(yaxis.min) - parseFloat(yminoff))), 
            null !== obj.options.ymax ? ystop = obj.options.yformat && "date" === obj.options.yformat.type ? obj.options.yformat.format ? yaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.ymax, obj.options.yformat.format)).getTime()) : yaxis.series_u2p($.jsDate.createDate(obj.options.ymax).getTime()) : yaxis.series_u2p(obj.options.ymax) : null !== ymaxoff && ("number" === $.type(ymaxoff) ? ystop = yaxis.series_u2p(yaxis.max + ymaxoff) : "string" === $.type(ymaxoff) && (ystop = yaxis.series_u2p(yaxis.max) + parseFloat(ymaxoff))), 
            null !== ystop && null !== ystart && (obj.gridStart = [ x, ystart ], obj.gridStop = [ x, ystop ], 
            mr.draw([ x, ystart ], [ x, ystop ], canvas._ctx, opts)));
        }, rendererDashedVerticalLine = function(mr, opts, obj, plot) {
            var dashPat, dashPatLen, yaxis, ystop, ystart, x, yminoff, ymaxoff, i, numDash, firstDashAdjust, b, e, j;
            for (dashPat = obj.options.dashPattern, dashPatLen = 0, i = 0; i < dashPat.length; i++) dashPatLen += dashPat[i];
            if (null !== obj.options.x && (mr.style = "line", opts.closePath = !1, yaxis = plot.axes[obj.options.yaxis], 
            x = plot.axes[obj.options.xaxis].series_u2p(obj.options.x), yminoff = obj.options.yminOffset || obj.options.yOffset, 
            ymaxoff = obj.options.ymaxOffset || obj.options.yOffset, obj.options.xformat && "date" === obj.options.xformat.type && (x = obj.options.xformat.format ? plot.axes[obj.options.xaxis].series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.x, obj.options.xformat.format)).getTime()) : plot.axes[obj.options.xaxis].series_u2p($.jsDate.createDate(obj.options.x).getTime())), 
            null !== obj.options.ymin ? ystart = obj.options.yformat && "date" === obj.options.yformat.type ? obj.options.yformat.format ? yaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.ymin, obj.options.yformat.format)).getTime()) : yaxis.series_u2p($.jsDate.createDate(obj.options.ymin).getTime()) : yaxis.series_u2p(obj.options.ymin) : null !== yminoff && ("number" === $.type(yminoff) ? ystart = yaxis.series_u2p(yaxis.min - yminoff) : "string" === $.type(yminoff) && (ystart = yaxis.series_u2p(yaxis.min) - parseFloat(yminoff))), 
            null !== obj.options.ymax ? ystop = obj.options.yformat && "date" === obj.options.yformat.type ? obj.options.yformat.format ? yaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.ymax, obj.options.yformat.format)).getTime()) : yaxis.series_u2p($.jsDate.createDate(obj.options.ymax).getTime()) : yaxis.series_u2p(obj.options.ymax) : null !== ymaxoff && ("number" === $.type(ymaxoff) ? ystop = yaxis.series_u2p(yaxis.max + ymaxoff) : "string" === $.type(ymaxoff) && (ystop = yaxis.series_u2p(yaxis.max) + parseFloat(ymaxoff))), 
            null !== ystop && null !== ystart)) for (obj.gridStart = [ x, ystart ], obj.gridStop = [ x, ystop ], 
            numDash = Math.ceil((ystart - ystop) / dashPatLen), firstDashAdjust = (numDash * dashPatLen - (ystart - ystop)) / 2, 
            b = ystart, i = 0; numDash > i; i++) for (j = 0; j < dashPat.length; j += 2) e = b - dashPat[j], 
            ystop > e && (e = ystop), ystop > b && (b = ystop), mr.draw([ x, b ], [ x, e ], canvas._ctx, opts), 
            b -= dashPat[j], j < dashPat.length - 1 && (b -= dashPat[j + 1]);
        }, rendererRectangle = function(mr, opts, obj, plot) {
            var xaxis, yaxis, y, x, xminoff, xmaxoff, yminoff, ymaxoff, xstart = null, xstop = null, ystart = null, ystop = null;
            mr.style = "line", opts.closePath = !0, xaxis = plot.axes[obj.options.xaxis], y = plot.axes[obj.options.yaxis].series_u2p(obj.options.y), 
            xminoff = obj.options.xminOffset || obj.options.xOffset, xmaxoff = obj.options.xmaxOffset || obj.options.xOffset, 
            null !== obj.options.xmin ? xstart = obj.options.xformat && "date" === obj.options.xformat.type ? obj.options.xformat.format ? xaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.xmin, obj.options.xformat.format)).getTime()) : xaxis.series_u2p($.jsDate.createDate(obj.options.xmin).getTime()) : xaxis.series_u2p(obj.options.xmin) : null !== xminoff && ("number" === $.type(xminoff) ? xstart = xaxis.series_u2p(xaxis.min + xminoff) : "string" === $.type(xminoff) && (xstart = xaxis.series_u2p(xaxis.min) + parseFloat(xminoff))), 
            null !== obj.options.xmax ? xstop = obj.options.xformat && "date" === obj.options.xformat.type ? obj.options.xformat.format ? xaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.xmax, obj.options.xformat.format)).getTime()) : xaxis.series_u2p($.jsDate.createDate(obj.options.xmax).getTime()) : xaxis.series_u2p(obj.options.xmax) : null !== xmaxoff && ("number" === $.type(xmaxoff) ? xstop = xaxis.series_u2p(xaxis.max - xmaxoff) : "string" === $.type(xmaxoff) && (xstop = xaxis.series_u2p(xaxis.max) - parseFloat(xmaxoff))), 
            yaxis = plot.axes[obj.options.yaxis], x = plot.axes[obj.options.xaxis].series_u2p(obj.options.x), 
            yminoff = obj.options.yminOffset || obj.options.yOffset, ymaxoff = obj.options.ymaxOffset || obj.options.yOffset, 
            null !== obj.options.ymin ? ystart = obj.options.yformat && "date" === obj.options.yformat.type ? obj.options.yformat.format ? yaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.ymin, obj.options.yformat.format)).getTime()) : yaxis.series_u2p($.jsDate.createDate(obj.options.ymin).getTime()) : yaxis.series_u2p(obj.options.ymin) : null !== yminoff && ("number" === $.type(yminoff) ? ystart = yaxis.series_u2p(yaxis.min - yminoff) : "string" === $.type(yminoff) && (ystart = yaxis.series_u2p(yaxis.min) - parseFloat(yminoff))), 
            null !== obj.options.ymax ? ystop = obj.options.yformat && "date" === obj.options.yformat.type ? obj.options.yformat.format ? yaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.ymax, obj.options.yformat.format)).getTime()) : yaxis.series_u2p($.jsDate.createDate(obj.options.ymax).getTime()) : yaxis.series_u2p(obj.options.ymax) : null !== ymaxoff && ("number" === $.type(ymaxoff) ? ystop = yaxis.series_u2p(yaxis.max + ymaxoff) : "string" === $.type(ymaxoff) && (ystop = yaxis.series_u2p(yaxis.max) + parseFloat(ymaxoff))), 
            null !== xstop && null !== xstart && null !== ystop && null !== ystart && (obj.gridStart = [ xstart, ystart ], 
            obj.gridStop = [ xstop, ystop ], canvas._ctx.fillStyle = obj.options.color, canvas._ctx.fillRect(xstart, ystart, xstop - xstart, ystop - ystart));
        }, rendererWorkItem = function(mr, opts, obj, plot) {
            var xaxis, yaxis, maxWorkItems = 5, xstart = null, ystart = null, xstop = null, ystop = null, workItemHeight = 0, maxHeight = 0, maxWidth = 0, currentWorkItem = (plot.objectCounter.workitem.total, 
            plot.objectCounter.workitem.current), $target = plot.target, $workitem = $("<div />", {
                "class": "jqplot-workitem",
                style: "position:absolute;"
            });
            mr.style = "line", opts.closePath = !0, xaxis = plot.axes[obj.options.xaxis], yaxis = plot.axes[obj.options.yaxis], 
            maxHeight = plot.grid._height || canvas._plotDimensions.height, maxWidth = plot.grid._width || canvas._plotDimensions.width, 
            null !== obj.options.xmin && (xstart = obj.options.xformat && "date" === obj.options.xformat.type ? obj.options.xformat.format ? xaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.xmin, obj.options.xformat.format)).getTime()) : xaxis.series_u2p($.jsDate.createDate(obj.options.xmin).getTime()) : xaxis.series_u2p(obj.options.xmin)), 
            null !== obj.options.xmax && (xstop = obj.options.xformat && "date" === obj.options.xformat.type ? obj.options.xformat.format ? xaxis.series_u2p($.jsDate.createDate($.jsDate.strftime(obj.options.xmax, obj.options.xformat.format)).getTime()) : xaxis.series_u2p($.jsDate.createDate(obj.options.xmax).getTime()) : xaxis.series_u2p(obj.options.xmax)), 
            workItemHeight = maxHeight / maxWorkItems, ystart = -(workItemHeight - currentWorkItem * workItemHeight), 
            ystop = workItemHeight, null !== xstop && null !== xstart && null !== ystop && null !== ystart && (obj.gridStart = [ xstart, ystart ], 
            obj.gridStop = [ xstop, ystop ], xstart >= 0 && xstart < plot.grid._width && ($workitem.css({
                top: ystart + plot._gridPadding.top + "px",
                left: xstart + plot._gridPadding.left + "px",
                height: ystop + "px",
                width: xstop - xstart + "px",
                backgroundColor: obj.options.color || ""
            }), obj.options.icon && $workitem.addClass("icon-" + obj.options.icon), obj.options.content && $workitem.html(obj.options.content), 
            obj.options.className && $workitem.addClass(obj.options.className), $target.append($workitem)));
        };
        if (this.options.show) {
            for (this.canvas._ctx.clearRect(0, 0, this.canvas.getWidth(), this.canvas.getHeight()), 
            $(plot.target).find(".jqplot-workitem").remove(), k = 0; objslen > k; k++) obj = objs[k], 
            opts = $.extend(!0, {}, obj.options), obj.options.show && (plot.objectCounter[obj.type] ? plot.objectCounter[obj.type].total++ : plot.objectCounter[obj.type] = {
                total: 1,
                current: 0
            });
            for (k = 0; objslen > k; k++) if (obj = objs[k], opts = $.extend(!0, {}, obj.options), 
            obj.options.show) switch (plot.objectCounter[obj.type] ? plot.objectCounter[obj.type].current++ : plot.objectCounter[obj.type].current = 1, 
            mr.shadow = obj.options.shadow, obj.tooltipWidthFactor = obj.options.lineWidth / obj.options.showTooltipPrecision, 
            obj.type) {
              case "line":
                rendererLine(mr, opts, obj, plot);
                break;

              case "horizontalLine":
                rendererHorizontalLine(mr, opts, obj, plot);
                break;

              case "dashedHorizontalLine":
                rendererDashedHorizontalLine(mr, opts, obj, plot);
                break;

              case "verticalLine":
                rendererVerticalLine(mr, opts, obj, plot);
                break;

              case "dashedVerticalLine":
                rendererDashedVerticalLine(mr, opts, obj, plot);
                break;

              case "rectangle":
                rendererRectangle(mr, opts, obj, plot);
                break;

              case "workitem":
                rendererWorkItem(mr, opts, obj, plot);
            }
        }
    }, $.jqplot.CanvasOverlay.postPlotDraw = function() {
        var targetCanvas, co = this.plugins.canvasOverlay;
        co && co.highlightCanvas && (co.highlightCanvas.resetCanvas(), co.highlightCanvas = null), 
        co.canvas = new $.jqplot.GenericCanvas(), targetCanvas = this.eventCanvas, this.plugins.canvasOverlay.options.bellowSeries === !0 && (targetCanvas = this.bellowSeriesCanvas), 
        targetCanvas._elem.before(co.canvas.createElement(this._gridPadding, "jqplot-overlayCanvas-canvas", this._plotDimensions, this)), 
        co.canvas.setContext(), co.deferDraw || co.draw(this), co._tooltipElem = $("<div/>", {
            "class": "jqplot-canvasOverlay-tooltip"
        }).css({
            position: "absolute",
            display: "none"
        }), targetCanvas._elem.before(co._tooltipElem), targetCanvas._elem.bind("mouseleave", {
            elem: co._tooltipElem
        }, function(ev) {
            ev.data.elem.hide();
        }), co = null;
    }, $.jqplot.postInitHooks.push($.jqplot.CanvasOverlay.postPlotInit), $.jqplot.postDrawHooks.push($.jqplot.CanvasOverlay.postPlotDraw), 
    $.jqplot.eventListenerHooks.push([ "jqplotMouseMove", handleMove ]);
}(jQuery);
//# sourceMappingURL=jqplot.canvasOverlay.min.js.map