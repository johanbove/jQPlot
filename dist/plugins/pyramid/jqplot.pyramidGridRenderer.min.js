!function($) {
    $.jqplot.PyramidGridRenderer = function() {
        $.jqplot.CanvasGridRenderer.call(this);
    }, $.jqplot.PyramidGridRenderer.prototype = new $.jqplot.CanvasGridRenderer(), $.jqplot.PyramidGridRenderer.prototype.constructor = $.jqplot.PyramidGridRenderer, 
    $.jqplot.CanvasGridRenderer.prototype.init = function(options) {
        this._ctx, this.plotBands = {
            show: !1,
            color: "rgb(230, 219, 179)",
            axis: "y",
            start: null,
            interval: 10
        }, $.extend(!0, this, options);
        var sopts = {
            lineJoin: "miter",
            lineCap: "round",
            fill: !1,
            isarc: !1,
            angle: this.shadowAngle,
            offset: this.shadowOffset,
            alpha: this.shadowAlpha,
            depth: this.shadowDepth,
            lineWidth: this.shadowWidth,
            closePath: !1,
            strokeStyle: this.shadowColor
        };
        this.renderer.shadowRenderer.init(sopts);
    }, $.jqplot.PyramidGridRenderer.prototype.draw = function() {
        function drawLine(bx, by, ex, ey, opts) {
            ctx.save(), opts = opts || {}, (null == opts.lineWidth || 0 != opts.lineWidth) && ($.extend(!0, ctx, opts), 
            ctx.beginPath(), ctx.moveTo(bx, by), ctx.lineTo(ex, ey), ctx.stroke()), ctx.restore();
        }
        this._ctx = this._elem.get(0).getContext("2d");
        var ctx = this._ctx, axes = this._axes, xp = axes.xaxis.u2p, xnudge = (axes.yMidAxis.u2p, 
        axes.xaxis.max / 1e3), xp0 = xp(0), xpn = xp(xnudge), ax = [ "xaxis", "yaxis", "x2axis", "y2axis", "yMidAxis" ];
        if (ctx.save(), ctx.clearRect(0, 0, this._plotDimensions.width, this._plotDimensions.height), 
        ctx.fillStyle = this.backgroundColor || this.background, ctx.fillRect(this._left, this._top, this._width, this._height), 
        this.plotBands.show) {
            ctx.save();
            var pb = this.plotBands;
            ctx.fillStyle = pb.color;
            var axis, x, y, w, h;
            if ("x" === pb.axis.charAt(0) ? axes.xaxis.show && (axis = axes.xaxis) : "y" === pb.axis.charAt(0) && (axes.yaxis.show ? axis = axes.yaxis : axes.y2axis.show ? axis = axes.y2axis : axes.yMidAxis.show && (axis = axes.yMidAxis)), 
            void 0 !== axis) {
                var start = pb.start;
                null === start && (start = axis.min);
                for (var i = start; i < axis.max; i += 2 * pb.interval) "y" === axis.name.charAt(0) && (x = this._left, 
                y = i + pb.interval < axis.max ? axis.series_u2p(i + pb.interval) + this._top : axis.series_u2p(axis.max) + this._top, 
                w = this._right - this._left, h = axis.series_u2p(start) - axis.series_u2p(start + pb.interval), 
                ctx.fillRect(x, y, w, h));
            }
            ctx.restore();
        }
        ctx.save(), ctx.lineJoin = "miter", ctx.lineCap = "butt", ctx.lineWidth = this.gridLineWidth, 
        ctx.strokeStyle = this.gridLineColor;
        for (var b, e, s, m, i = 5; i > 0; i--) {
            var name = ax[i - 1], axis = axes[name], ticks = axis._ticks, numticks = ticks.length;
            if (axis.show) {
                if (axis.drawBaseline) {
                    var bopts = {};
                    switch (null !== axis.baselineWidth && (bopts.lineWidth = axis.baselineWidth), null !== axis.baselineColor && (bopts.strokeStyle = axis.baselineColor), 
                    name) {
                      case "xaxis":
                        axes.yMidAxis.show ? (drawLine(this._left, this._bottom, xp0, this._bottom, bopts), 
                        drawLine(xpn, this._bottom, this._right, this._bottom, bopts)) : drawLine(this._left, this._bottom, this._right, this._bottom, bopts);
                        break;

                      case "yaxis":
                        drawLine(this._left, this._bottom, this._left, this._top, bopts);
                        break;

                      case "yMidAxis":
                        drawLine(xp0, this._bottom, xp0, this._top, bopts), drawLine(xpn, this._bottom, xpn, this._top, bopts);
                        break;

                      case "x2axis":
                        axes.yMidAxis.show ? (drawLine(this._left, this._top, xp0, this._top, bopts), drawLine(xpn, this._top, this._right, this._top, bopts)) : drawLine(this._left, this._bottom, this._right, this._bottom, bopts);
                        break;

                      case "y2axis":
                        drawLine(this._right, this._bottom, this._right, this._top, bopts);
                    }
                }
                for (var j = numticks; j > 0; j--) {
                    var t = ticks[j - 1];
                    if (t.show) {
                        var pos = Math.round(axis.u2p(t.value)) + .5;
                        switch (name) {
                          case "xaxis":
                            if (t.showGridline && this.drawGridlines && (!t.isMinorTick || axis.showMinorTicks) && drawLine(pos, this._top, pos, this._bottom), 
                            t.showMark && t.mark && (!t.isMinorTick || axis.showMinorTicks)) {
                                s = t.markSize, m = t.mark;
                                var pos = Math.round(axis.u2p(t.value)) + .5;
                                switch (m) {
                                  case "outside":
                                    b = this._bottom, e = this._bottom + s;
                                    break;

                                  case "inside":
                                    b = this._bottom - s, e = this._bottom;
                                    break;

                                  case "cross":
                                    b = this._bottom - s, e = this._bottom + s;
                                    break;

                                  default:
                                    b = this._bottom, e = this._bottom + s;
                                }
                                this.shadow && this.renderer.shadowRenderer.draw(ctx, [ [ pos, b ], [ pos, e ] ], {
                                    lineCap: "butt",
                                    lineWidth: this.gridLineWidth,
                                    offset: .75 * this.gridLineWidth,
                                    depth: 2,
                                    fill: !1,
                                    closePath: !1
                                }), drawLine(pos, b, pos, e);
                            }
                            break;

                          case "yaxis":
                            if (t.showGridline && this.drawGridlines && (!t.isMinorTick || axis.showMinorTicks) && drawLine(this._right, pos, this._left, pos), 
                            t.showMark && t.mark && (!t.isMinorTick || axis.showMinorTicks)) {
                                s = t.markSize, m = t.mark;
                                var pos = Math.round(axis.u2p(t.value)) + .5;
                                switch (m) {
                                  case "outside":
                                    b = this._left - s, e = this._left;
                                    break;

                                  case "inside":
                                    b = this._left, e = this._left + s;
                                    break;

                                  case "cross":
                                    b = this._left - s, e = this._left + s;
                                    break;

                                  default:
                                    b = this._left - s, e = this._left;
                                }
                                this.shadow && this.renderer.shadowRenderer.draw(ctx, [ [ b, pos ], [ e, pos ] ], {
                                    lineCap: "butt",
                                    lineWidth: 1.5 * this.gridLineWidth,
                                    offset: .75 * this.gridLineWidth,
                                    fill: !1,
                                    closePath: !1
                                }), drawLine(b, pos, e, pos, {
                                    strokeStyle: axis.borderColor
                                });
                            }
                            break;

                          case "yMidAxis":
                            if (t.showGridline && this.drawGridlines && (!t.isMinorTick || axis.showMinorTicks) && (drawLine(this._left, pos, xp0, pos), 
                            drawLine(xpn, pos, this._right, pos)), t.showMark && t.mark && (!t.isMinorTick || axis.showMinorTicks)) {
                                s = t.markSize, m = t.mark;
                                var pos = Math.round(axis.u2p(t.value)) + .5;
                                b = xp0, e = xp0 + s, this.shadow && this.renderer.shadowRenderer.draw(ctx, [ [ b, pos ], [ e, pos ] ], {
                                    lineCap: "butt",
                                    lineWidth: 1.5 * this.gridLineWidth,
                                    offset: .75 * this.gridLineWidth,
                                    fill: !1,
                                    closePath: !1
                                }), drawLine(b, pos, e, pos, {
                                    strokeStyle: axis.borderColor
                                }), b = xpn - s, e = xpn, this.shadow && this.renderer.shadowRenderer.draw(ctx, [ [ b, pos ], [ e, pos ] ], {
                                    lineCap: "butt",
                                    lineWidth: 1.5 * this.gridLineWidth,
                                    offset: .75 * this.gridLineWidth,
                                    fill: !1,
                                    closePath: !1
                                }), drawLine(b, pos, e, pos, {
                                    strokeStyle: axis.borderColor
                                });
                            }
                            break;

                          case "x2axis":
                            if (t.showGridline && this.drawGridlines && (!t.isMinorTick || axis.showMinorTicks) && drawLine(pos, this._bottom, pos, this._top), 
                            t.showMark && t.mark && (!t.isMinorTick || axis.showMinorTicks)) {
                                s = t.markSize, m = t.mark;
                                var pos = Math.round(axis.u2p(t.value)) + .5;
                                switch (m) {
                                  case "outside":
                                    b = this._top - s, e = this._top;
                                    break;

                                  case "inside":
                                    b = this._top, e = this._top + s;
                                    break;

                                  case "cross":
                                    b = this._top - s, e = this._top + s;
                                    break;

                                  default:
                                    b = this._top - s, e = this._top;
                                }
                                this.shadow && this.renderer.shadowRenderer.draw(ctx, [ [ pos, b ], [ pos, e ] ], {
                                    lineCap: "butt",
                                    lineWidth: this.gridLineWidth,
                                    offset: .75 * this.gridLineWidth,
                                    depth: 2,
                                    fill: !1,
                                    closePath: !1
                                }), drawLine(pos, b, pos, e);
                            }
                            break;

                          case "y2axis":
                            if (t.showGridline && this.drawGridlines && (!t.isMinorTick || axis.showMinorTicks) && drawLine(this._left, pos, this._right, pos), 
                            t.showMark && t.mark && (!t.isMinorTick || axis.showMinorTicks)) {
                                s = t.markSize, m = t.mark;
                                var pos = Math.round(axis.u2p(t.value)) + .5;
                                switch (m) {
                                  case "outside":
                                    b = this._right, e = this._right + s;
                                    break;

                                  case "inside":
                                    b = this._right - s, e = this._right;
                                    break;

                                  case "cross":
                                    b = this._right - s, e = this._right + s;
                                    break;

                                  default:
                                    b = this._right, e = this._right + s;
                                }
                                this.shadow && this.renderer.shadowRenderer.draw(ctx, [ [ b, pos ], [ e, pos ] ], {
                                    lineCap: "butt",
                                    lineWidth: 1.5 * this.gridLineWidth,
                                    offset: .75 * this.gridLineWidth,
                                    fill: !1,
                                    closePath: !1
                                }), drawLine(b, pos, e, pos, {
                                    strokeStyle: axis.borderColor
                                });
                            }
                        }
                    }
                }
                t = null;
            }
            axis = null, ticks = null;
        }
        if (ctx.restore(), this.shadow) if (axes.yMidAxis.show) {
            var points = [ [ this._left, this._bottom ], [ xp0, this._bottom ] ];
            this.renderer.shadowRenderer.draw(ctx, points);
            var points = [ [ xpn, this._bottom ], [ this._right, this._bottom ], [ this._right, this._top ] ];
            this.renderer.shadowRenderer.draw(ctx, points);
            var points = [ [ xp0, this._bottom ], [ xp0, this._top ] ];
            this.renderer.shadowRenderer.draw(ctx, points);
        } else {
            var points = [ [ this._left, this._bottom ], [ this._right, this._bottom ], [ this._right, this._top ] ];
            this.renderer.shadowRenderer.draw(ctx, points);
        }
        0 != this.borderWidth && this.drawBorder && (axes.yMidAxis.show ? (drawLine(this._left, this._top, xp0, this._top, {
            lineCap: "round",
            strokeStyle: axes.x2axis.borderColor,
            lineWidth: axes.x2axis.borderWidth
        }), drawLine(xpn, this._top, this._right, this._top, {
            lineCap: "round",
            strokeStyle: axes.x2axis.borderColor,
            lineWidth: axes.x2axis.borderWidth
        }), drawLine(this._right, this._top, this._right, this._bottom, {
            lineCap: "round",
            strokeStyle: axes.y2axis.borderColor,
            lineWidth: axes.y2axis.borderWidth
        }), drawLine(this._right, this._bottom, xpn, this._bottom, {
            lineCap: "round",
            strokeStyle: axes.xaxis.borderColor,
            lineWidth: axes.xaxis.borderWidth
        }), drawLine(xp0, this._bottom, this._left, this._bottom, {
            lineCap: "round",
            strokeStyle: axes.xaxis.borderColor,
            lineWidth: axes.xaxis.borderWidth
        }), drawLine(this._left, this._bottom, this._left, this._top, {
            lineCap: "round",
            strokeStyle: axes.yaxis.borderColor,
            lineWidth: axes.yaxis.borderWidth
        }), drawLine(xp0, this._bottom, xp0, this._top, {
            lineCap: "round",
            strokeStyle: axes.yaxis.borderColor,
            lineWidth: axes.yaxis.borderWidth
        }), drawLine(xpn, this._bottom, xpn, this._top, {
            lineCap: "round",
            strokeStyle: axes.yaxis.borderColor,
            lineWidth: axes.yaxis.borderWidth
        })) : (drawLine(this._left, this._top, this._right, this._top, {
            lineCap: "round",
            strokeStyle: axes.x2axis.borderColor,
            lineWidth: axes.x2axis.borderWidth
        }), drawLine(this._right, this._top, this._right, this._bottom, {
            lineCap: "round",
            strokeStyle: axes.y2axis.borderColor,
            lineWidth: axes.y2axis.borderWidth
        }), drawLine(this._right, this._bottom, this._left, this._bottom, {
            lineCap: "round",
            strokeStyle: axes.xaxis.borderColor,
            lineWidth: axes.xaxis.borderWidth
        }), drawLine(this._left, this._bottom, this._left, this._top, {
            lineCap: "round",
            strokeStyle: axes.yaxis.borderColor,
            lineWidth: axes.yaxis.borderWidth
        }))), ctx.restore(), ctx = null, axes = null;
    };
}(jQuery);
//# sourceMappingURL=jqplot.pyramidGridRenderer.min.js.map