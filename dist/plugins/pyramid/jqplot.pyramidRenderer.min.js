!function($) {
    function preInit(target, data, options) {
        options = options || {}, options.axesDefaults = options.axesDefaults || {}, options.grid = options.grid || {}, 
        options.legend = options.legend || {}, options.seriesDefaults = options.seriesDefaults || {};
        var setopts = !1;
        if (options.seriesDefaults.renderer === $.jqplot.PyramidRenderer) setopts = !0; else if (options.series) for (var i = 0; i < options.series.length; i++) options.series[i].renderer === $.jqplot.PyramidRenderer && (setopts = !0);
        setopts && (options.axesDefaults.renderer = $.jqplot.PyramidAxisRenderer, options.grid.renderer = $.jqplot.PyramidGridRenderer, 
        options.seriesDefaults.pointLabels = {
            show: !1
        });
    }
    function postPlotDraw() {
        this.plugins.pyramidRenderer && this.plugins.pyramidRenderer.highlightCanvas && (this.plugins.pyramidRenderer.highlightCanvas.resetCanvas(), 
        this.plugins.pyramidRenderer.highlightCanvas = null), this.plugins.pyramidRenderer = {
            highlightedSeriesIndex: null
        }, this.plugins.pyramidRenderer.highlightCanvas = new $.jqplot.GenericCanvas(), 
        this.eventCanvas._elem.before(this.plugins.pyramidRenderer.highlightCanvas.createElement(this._gridPadding, "jqplot-pyramidRenderer-highlight-canvas", this._plotDimensions, this)), 
        this.plugins.pyramidRenderer.highlightCanvas.setContext(), this.eventCanvas._elem.bind("mouseleave", {
            plot: this
        }, function(ev) {
            unhighlight(ev.data.plot);
        });
    }
    function highlight(plot, sidx, pidx, points) {
        var s = plot.series[sidx], canvas = plot.plugins.pyramidRenderer.highlightCanvas;
        canvas._ctx.clearRect(0, 0, canvas._ctx.canvas.width, canvas._ctx.canvas.height), 
        s._highlightedPoint = pidx, plot.plugins.pyramidRenderer.highlightedSeriesIndex = sidx;
        var opts = {
            fillStyle: s.highlightColors[pidx],
            fillRect: !1
        };
        s.renderer.shapeRenderer.draw(canvas._ctx, points, opts), s.synchronizeHighlight !== !1 && plot.series.length >= s.synchronizeHighlight && s.synchronizeHighlight !== sidx && (s = plot.series[s.synchronizeHighlight], 
        opts = {
            fillStyle: s.highlightColors[pidx],
            fillRect: !1
        }, s.renderer.shapeRenderer.draw(canvas._ctx, s._barPoints[pidx], opts)), canvas = null;
    }
    function unhighlight(plot) {
        var canvas = plot.plugins.pyramidRenderer.highlightCanvas;
        canvas._ctx.clearRect(0, 0, canvas._ctx.canvas.width, canvas._ctx.canvas.height);
        for (var i = 0; i < plot.series.length; i++) plot.series[i]._highlightedPoint = null;
        plot.plugins.pyramidRenderer.highlightedSeriesIndex = null, plot.target.trigger("jqplotDataUnhighlight"), 
        canvas = null;
    }
    function handleMove(ev, gridpos, datapos, neighbor, plot) {
        if (neighbor) {
            var ins = [ neighbor.seriesIndex, neighbor.pointIndex, neighbor.data ], evt1 = jQuery.Event("jqplotDataMouseOver");
            if (evt1.pageX = ev.pageX, evt1.pageY = ev.pageY, plot.target.trigger(evt1, ins), 
            plot.series[ins[0]].highlightMouseOver && (ins[0] != plot.plugins.pyramidRenderer.highlightedSeriesIndex || ins[1] != plot.series[ins[0]]._highlightedPoint)) {
                var evt = jQuery.Event("jqplotDataHighlight");
                evt.which = ev.which, evt.pageX = ev.pageX, evt.pageY = ev.pageY, plot.target.trigger(evt, ins), 
                highlight(plot, neighbor.seriesIndex, neighbor.pointIndex, neighbor.points);
            }
        } else null == neighbor && unhighlight(plot);
    }
    $.jqplot.PyramidRenderer = function() {
        $.jqplot.LineRenderer.call(this);
    }, $.jqplot.PyramidRenderer.prototype = new $.jqplot.LineRenderer(), $.jqplot.PyramidRenderer.prototype.constructor = $.jqplot.PyramidRenderer, 
    $.jqplot.PyramidRenderer.prototype.init = function(options, plot) {
        options = options || {}, this._type = "pyramid", this.barPadding = 10, this.barWidth = null, 
        this.fill = !0, this.highlightMouseOver = !0, this.highlightMouseDown = !1, this.highlightColors = [], 
        this.highlightThreshold = 2, this.synchronizeHighlight = !1, this.offsetBars = !1, 
        options.highlightMouseDown && null == options.highlightMouseOver && (options.highlightMouseOver = !1), 
        this.side = "right", $.extend(!0, this, options), "left" === this.side ? this._highlightThreshold = [ [ -this.highlightThreshold, 0 ], [ -this.highlightThreshold, 0 ], [ 0, 0 ], [ 0, 0 ] ] : this._highlightThreshold = [ [ 0, 0 ], [ 0, 0 ], [ this.highlightThreshold, 0 ], [ this.highlightThreshold, 0 ] ], 
        this.renderer.options = options, this._highlightedPoint = null, this._dataColors = [], 
        this._barPoints = [], this.fillAxis = "y", this._primaryAxis = "_yaxis", this._xnudge = 0;
        var opts = {
            lineJoin: "miter",
            lineCap: "butt",
            fill: this.fill,
            fillRect: this.fill,
            isarc: !1,
            strokeStyle: this.color,
            fillStyle: this.color,
            closePath: this.fill,
            lineWidth: this.lineWidth
        };
        this.renderer.shapeRenderer.init(opts);
        var shadow_offset = options.shadowOffset;
        null == shadow_offset && (shadow_offset = this.lineWidth > 2.5 ? 1.25 * (1 + .6 * (Math.atan(this.lineWidth / 2.5) / .785398163 - 1)) : 1.25 * Math.atan(this.lineWidth / 2.5) / .785398163);
        var sopts = {
            lineJoin: "miter",
            lineCap: "butt",
            fill: this.fill,
            fillRect: this.fill,
            isarc: !1,
            angle: this.shadowAngle,
            offset: shadow_offset,
            alpha: this.shadowAlpha,
            depth: this.shadowDepth,
            closePath: this.fill,
            lineWidth: this.lineWidth
        };
        if (this.renderer.shadowRenderer.init(sopts), plot.postDrawHooks.addOnce(postPlotDraw), 
        plot.eventListenerHooks.addOnce("jqplotMouseMove", handleMove), "left" === this.side) for (var i = 0, l = this.data.length; l > i; i++) this.data[i][1] = -Math.abs(this.data[i][1]);
    }, $.jqplot.PyramidRenderer.prototype.setGridData = function(plot) {
        var xp = this._xaxis.series_u2p, yp = this._yaxis.series_u2p, data = this._plotData;
        this._prevPlotData;
        this.gridData = [], this._prevGridData = [];
        var i, l = data.length, adjust = !1;
        for (i = 0; l > i; i++) data[i][1] < 0 && (this.side = "left");
        for ("yMidAxis" === this._yaxis.name && "right" === this.side && (this._xnudge = this._xaxis.max / 2e3, 
        adjust = !0), i = 0; l > i; i++) null != data[i][0] && null != data[i][1] ? this.gridData.push([ xp(data[i][1]), yp(data[i][0]) ]) : null == data[i][0] ? this.gridData.push([ xp(data[i][1]), null ]) : null == data[i][1] && this.gridData.push(null, [ yp(data[i][0]) ]), 
        0 === data[i][1] && adjust && (this.gridData[i][0] = xp(this._xnudge));
    }, $.jqplot.PyramidRenderer.prototype.makeGridData = function(data, plot) {
        var i, xp = this._xaxis.series_u2p, yp = this._yaxis.series_u2p, gd = [], l = data.length, adjust = !1;
        for (i = 0; l > i; i++) data[i][1] < 0 && (this.side = "left");
        for ("yMidAxis" === this._yaxis.name && "right" === this.side && (this._xnudge = this._xaxis.max / 2e3, 
        adjust = !0), i = 0; l > i; i++) null != data[i][0] && null != data[i][1] ? gd.push([ xp(data[i][1]), yp(data[i][0]) ]) : null == data[i][0] ? gd.push([ xp(data[i][1]), null ]) : null == data[i][1] && gd.push([ null, yp(data[i][0]) ]), 
        0 === data[i][1] && adjust && (gd[i][0] = xp(this._xnudge));
        return gd;
    }, $.jqplot.PyramidRenderer.prototype.setBarWidth = function() {
        var nvals = 0, paxis = this[this._primaryAxis];
        nvals = paxis.max - paxis.min;
        var temp = (paxis.numberTicks, 0 === this.barPadding ? 1 : 0);
        "xaxis" == paxis.name || "x2axis" == paxis.name ? this.barWidth = (paxis._offsets.max - paxis._offsets.min) / nvals - this.barPadding + temp : this.fill ? this.barWidth = (paxis._offsets.min - paxis._offsets.max) / nvals - this.barPadding + temp : this.barWidth = (paxis._offsets.min - paxis._offsets.max) / nvals;
    }, $.jqplot.PyramidRenderer.prototype.draw = function(ctx, gridData, options) {
        var i, opts = $.extend({}, options), shadow = void 0 != opts.shadow ? opts.shadow : this.shadow, showLine = void 0 != opts.showLine ? opts.showLine : this.showLine;
        void 0 != opts.fill ? opts.fill : this.fill, this._xaxis.series_u2p, this._yaxis.series_u2p;
        this._dataColors = [], this._barPoints = [], null == this.renderer.options.barWidth && this.renderer.setBarWidth.call(this);
        var w, h, points = [];
        if (showLine) {
            var negativeColors = new $.jqplot.ColorGenerator(this.negativeSeriesColors), positiveColors = new $.jqplot.ColorGenerator(this.seriesColors), negativeColor = negativeColors.get(this.index);
            this.useNegativeColors || (negativeColor = opts.fillStyle);
            for (var base, positiveColor = opts.fillStyle, xstart = this._xaxis.series_u2p(this._xnudge), ystart = this._yaxis.series_u2p(this._yaxis.min), yend = this._yaxis.series_u2p(this._yaxis.max), bw = this.barWidth, bw2 = bw / 2, points = [], yadj = this.offsetBars ? bw2 : 0, i = 0, l = gridData.length; l > i; i++) if (null != this.data[i][0]) if (base = gridData[i][1], 
            this._plotData[i][1] < 0 ? this.varyBarColor && !this._stack && (this.useNegativeColors ? opts.fillStyle = negativeColors.next() : opts.fillStyle = positiveColors.next()) : this.varyBarColor && !this._stack ? opts.fillStyle = positiveColors.next() : opts.fillStyle = positiveColor, 
            this.fill) {
                this._plotData[i][1] >= 0 ? (w = gridData[i][0] - xstart, h = this.barWidth, points = [ xstart, base - bw2 - yadj, w, h ]) : (w = xstart - gridData[i][0], 
                h = this.barWidth, points = [ gridData[i][0], base - bw2 - yadj, w, h ]), this._barPoints.push([ [ points[0], points[1] + h ], [ points[0], points[1] ], [ points[0] + w, points[1] ], [ points[0] + w, points[1] + h ] ]), 
                shadow && this.renderer.shadowRenderer.draw(ctx, points);
                var clr = opts.fillStyle || this.color;
                this._dataColors.push(clr), this.renderer.shapeRenderer.draw(ctx, points, opts);
            } else if (0 === i) points = [ [ xstart, ystart ], [ gridData[i][0], ystart ], [ gridData[i][0], gridData[i][1] - bw2 - yadj ] ]; else if (l - 1 > i) points = points.concat([ [ gridData[i - 1][0], gridData[i - 1][1] - bw2 - yadj ], [ gridData[i][0], gridData[i][1] + bw2 - yadj ], [ gridData[i][0], gridData[i][1] - bw2 - yadj ] ]); else {
                points = points.concat([ [ gridData[i - 1][0], gridData[i - 1][1] - bw2 - yadj ], [ gridData[i][0], gridData[i][1] + bw2 - yadj ], [ gridData[i][0], yend ], [ xstart, yend ] ]), 
                shadow && this.renderer.shadowRenderer.draw(ctx, points);
                var clr = opts.fillStyle || this.color;
                this._dataColors.push(clr), this.renderer.shapeRenderer.draw(ctx, points, opts);
            }
        }
        if (0 == this.highlightColors.length) this.highlightColors = $.jqplot.computeHighlightColors(this._dataColors); else if ("string" == typeof this.highlightColors) {
            this.highlightColors = [];
            for (var i = 0; i < this._dataColors.length; i++) this.highlightColors.push(this.highlightColors);
        }
    }, $.jqplot.preInitHooks.push(preInit);
}(jQuery);
//# sourceMappingURL=jqplot.pyramidRenderer.min.js.map