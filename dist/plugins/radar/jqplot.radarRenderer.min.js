!function($) {
    function preInit(target, data, options) {
        options = options || {}, options.axesDefaults = options.axesDefaults || {}, options.legend = options.legend || {}, 
        options.seriesDefaults = options.seriesDefaults || {};
    }
    function postParseOptions(options) {
        for (var i = 0; i < this.series.length; i++) this.series[i].seriesColors = this.seriesColors, 
        this.series[i].colorGenerator = $.jqplot.colorGenerator;
    }
    function postInit(target, data, options) {
        for (var i = 0; i < this.series.length; i++) this.series[i].renderer.constructor == $.jqplot.RadarRenderer && this.series[i].highlightMouseOver && (this.series[i].highlightMouseDown = !1);
    }
    $.jqplot.RadarRenderer = function() {
        $.jqplot.LineRenderer.call(this);
    }, $.jqplot.RadarRenderer.prototype = new $.jqplot.LineRenderer(), $.jqplot.RadarRenderer.prototype.constructor = $.jqplot.RadarRenderer, 
    $.jqplot.RadarRenderer.prototype.init = function(options, plot) {
        if (this.diameter = null, this.highlightColors = [], 0 == this.highlightColors.length) for (var i = 0; i < this.seriesColors.length; i++) {
            for (var rgba = $.jqplot.getColorComponents(this.seriesColors[i]), newrgb = [ rgba[0], rgba[1], rgba[2] ], sum = newrgb[0] + newrgb[1] + newrgb[2], j = 0; 3 > j; j++) newrgb[j] = sum > 570 ? .8 * newrgb[j] : newrgb[j] + .3 * (255 - newrgb[j]), 
            newrgb[j] = parseInt(newrgb[j], 10);
            this.highlightColors.push("rgb(" + newrgb[0] + "," + newrgb[1] + "," + newrgb[2] + ")");
        }
        this.highlightColorGenerator = new $.jqplot.ColorGenerator(this.highlightColors), 
        this.renderer.options = options, $.extend(!0, this, options), plot.postParseOptionsHooks.addOnce(postParseOptions), 
        plot.postInitHooks.addOnce(postInit);
    }, $.jqplot.RadarRenderer.prototype.drawLine = function(ctx, datas, color) {}, $.jqplot.RadarRenderer.prototype.doDraw = function(ctx, x, y, color) {}, 
    $.jqplot.RadarRenderer.prototype.drawScales = function(ctx) {
        var data = this.data;
        console.log(this);
        var rotationDegree = 2 * Math.PI / data.length;
        if (ctx.save(), ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2), this.angleShowLineOut) {
            ctx.strokeStyle = this.angleLineColor, ctx.lineWidth = this.angleLineWidth;
            for (var h = 0; h < data.length; h++) ctx.rotate(rotationDegree), ctx.beginPath(), 
            ctx.moveTo(0, 0), ctx.lineTo(0, -maxSize), ctx.stroke();
        }
        for (var i = 0; i < this._calculatedScale.steps; i++) {
            if (ctx.beginPath(), this.renderer.options.scaleShowLine) {
                ctx.strokeStyle = this.renderer.options.scaleLineColor, ctx.lineWidth = this.scaleLineWidth, 
                ctx.moveTo(0, -this._calculatedScale.scaleHop * (i + 1));
                for (var j = 0; j < data.length; j++) ctx.rotate(rotationDegree), ctx.lineTo(0, -this._calculatedScale.scaleHop * (i + 1));
                ctx.closePath(), ctx.stroke();
            }
            if (this.renderer.options.scaleShowLabels) {
                if (ctx.textAlign = "center", ctx.font = this.scaleFontStyle + " " + this.scaleFontSize + "px " + this.scaleFontFamily, 
                ctx.textBaseline = "middle", this.scaleShowLabelBackdrop) {
                    var textWidth = ctx.measureText(this._calculatedScale.labels[i]).width;
                    ctx.fillStyle = this.scaleBackdropColor, ctx.beginPath(), ctx.rect(Math.round(-textWidth / 2 - this.scaleBackdropPaddingX), Math.round(-this._calculatedScale.scaleHop * (i + 1) - .5 * this.scaleFontSize - this.scaleBackdropPaddingY), Math.round(textWidth + 2 * this.scaleBackdropPaddingX), Math.round(this.scaleFontSize + 2 * this.scaleBackdropPaddingY)), 
                    ctx.fill();
                }
                ctx.fillStyle = this.scaleFontColor, ctx.fillText(this._calculatedScale.labels[i], 0, -this._calculatedScale.scaleHop * (i + 1));
            }
        }
        for (var k = 0; data > k; k++) {
            ctx.font = this.pointLabelFontStyle + " " + this.pointLabelFontSize + "px " + this.pointLabelFontFamily, 
            ctx.fillStyle = this.renderer.options.pointLabelFontColor;
            var opposite = Math.sin(rotationDegree * k) * (maxSize + this.pointLabelFontSize), adjacent = Math.cos(rotationDegree * k) * (maxSize + this.pointLabelFontSize);
            rotationDegree * k == Math.PI || rotationDegree * k == 0 ? ctx.textAlign = "center" : rotationDegree * k > Math.PI ? ctx.textAlign = "right" : ctx.textAlign = "left", 
            ctx.textBaseline = "middle", ctx.fillText(data[k], opposite, -adjacent);
        }
        ctx.restore();
    }, $.jqplot.RadarRenderer.prototype.drawOrigin = function(ctx, options) {
        var offx = 0, offy = 0, trans = 1;
        if (options.legendInfo && "insideGrid" == options.legendInfo.placement) {
            var li = options.legendInfo;
            switch (li.location) {
              case "nw":
                offx = li.width + li.xoffset;
                break;

              case "w":
                offx = li.width + li.xoffset;
                break;

              case "sw":
                offx = li.width + li.xoffset;
                break;

              case "ne":
                offx = li.width + li.xoffset, trans = -1;
                break;

              case "e":
                offx = li.width + li.xoffset, trans = -1;
                break;

              case "se":
                offx = li.width + li.xoffset, trans = -1;
                break;

              case "n":
                offy = li.height + li.yoffset;
                break;

              case "s":
                offy = li.height + li.yoffset, trans = -1;
            }
        }
        var cw = ctx.canvas.width, ch = ctx.canvas.height;
        this._center = [ (cw - trans * offx) / 2 + trans * offx, (ch - trans * offy) / 2 + trans * offy ], 
        ctx.strokeStyle = "red", ctx.beginPath(), ctx.arc(this._center[0], this._center[1], 5, 0, 2 * Math.PI, !0), 
        ctx.stroke();
    }, $.jqplot.RadarRenderer.prototype.draw = function(ctx, gridData, options, plot) {
        $.extend({}, this.renderer.options);
        console.log(gridData), xmin = this._xaxis._min, xmax = this._xaxis._max, ticks = [];
        for (var i = 0; i < this._xaxis._ticks.length; i += 1) ticks[i] = this._xaxis._ticks[i].label;
        console.log(ticks), stepCount = ticks.length, scaleHop = ctx.canvas.width / (2 * stepCount), 
        this._calculatedScale = {
            steps: stepCount,
            scaleHop: scaleHop,
            graphMin: xmin,
            labels: ticks
        }, this.renderer.drawScales.call(this, ctx), this.renderer.drawOrigin.call(this, ctx, options);
        for (var i = 0, l = gridData.length; l > i; i++) {
            if (null != this.data[i][0]) {
                base = gridData[i][0], lineDatas = [];
                for (var j = 0, size = gridData[i].length; size > j; j++) j % 2 == 0 && console.log(gridData[i][j] - this._center[0]);
            }
        }
    }, $.jqplot.preInitHooks.push(preInit);
}(jQuery);
//# sourceMappingURL=jqplot.radarRenderer.min.js.map